1
00:00:01,000 --> 00:00:07,070
let's imagine three servers with logs

2
00:00:07,070 --> 00:00:13,400
that looked like this where the numbers

3
00:00:13,400 --> 00:00:15,320
I'm writing are the term numbers of the

4
00:00:15,320 --> 00:00:17,060
command that's in that log entry so we

5
00:00:17,060 --> 00:00:18,500
don't really care what the actual

6
00:00:18,500 --> 00:00:20,779
commands are then I got a number the log

7
00:00:20,779 --> 00:00:35,290
slots and so let's imagine that the

8
00:00:35,290 --> 00:00:38,840
presumably the the next term is term six

9
00:00:38,840 --> 00:00:40,820
although you can't actually tell that

10
00:00:40,820 --> 00:00:42,500
from looking the evidence on the board

11
00:00:42,500 --> 00:00:44,770
but it must be at least six or greater

12
00:00:44,770 --> 00:00:47,480
let's imagine that server s3 is chosen

13
00:00:47,480 --> 00:00:52,579
as the leader for term six and at some

14
00:00:52,579 --> 00:00:56,120
point s3 the new leader is going to want

15
00:00:56,120 --> 00:00:58,309
to send out a new log entry so let's

16
00:00:58,309 --> 00:01:00,110
suppose it wants to send out its first

17
00:01:00,110 --> 00:01:02,989
log entry per term six so we're sort of

18
00:01:02,989 --> 00:01:04,459
thinking about the append entries our

19
00:01:04,459 --> 00:01:06,200
PCs that the leader is going to send out

20
00:01:06,200 --> 00:01:11,299
to carry the first log entry for term

21
00:01:11,299 --> 00:01:13,899
six really should be under slot thirteen

22
00:01:13,899 --> 00:01:16,459
the rules in Figure two say that an

23
00:01:16,459 --> 00:01:18,920
append entries are bc actually as - as

24
00:01:18,920 --> 00:01:22,099
well as the command that the client sent

25
00:01:22,099 --> 00:01:23,119
in to the leader that we want to

26
00:01:23,119 --> 00:01:25,039
replicate on the logs of all the

27
00:01:25,039 --> 00:01:28,130
followers there's this append entries

28
00:01:28,130 --> 00:01:33,279
RPC also contains this previous log

29
00:01:33,279 --> 00:01:39,469
index field and a previous log term

30
00:01:39,469 --> 00:01:44,270
field and when we're sending out an end

31
00:01:44,270 --> 00:01:46,429
pend entries for where this is the first

32
00:01:46,429 --> 00:01:48,859
entry we're leaders supposed to put

33
00:01:48,859 --> 00:01:51,380
information about the previous slot the

34
00:01:51,380 --> 00:01:54,679
slot before the new information sending

35
00:01:54,679 --> 00:01:57,169
out so in this case the log index of the

36
00:01:57,169 --> 00:02:04,029
previous entry is 12 and the term of the

37
00:02:04,029 --> 00:02:06,709
command in the leaders log for the

38
00:02:06,709 --> 00:02:10,758
previous entry is by so sends out this

39
00:02:10,758 --> 00:02:13,400
information to the followers

40
00:02:13,400 --> 00:02:16,409
and the followers before they accept a

41
00:02:16,409 --> 00:02:18,959
upend entries are supposed to check you

42
00:02:18,959 --> 00:02:19,890
know they know they've received an

43
00:02:19,890 --> 00:02:23,909
append entries that for some log entries

44
00:02:23,909 --> 00:02:26,849
that start here and the first thing they

45
00:02:26,849 --> 00:02:29,310
do is check that there are previous the

46
00:02:29,310 --> 00:02:30,930
receiving followers check that their

47
00:02:30,930 --> 00:02:34,200
previous log entry matches the previous

48
00:02:34,200 --> 00:02:36,120
information that follow that the leader

49
00:02:36,120 --> 00:02:38,310
sent out so for a server to of course it

50
00:02:38,310 --> 00:02:42,360
doesn't match the server to has a entry

51
00:02:42,360 --> 00:02:43,950
here all right but it's an entry from

52
00:02:43,950 --> 00:02:46,799
term for not from turn five and so the

53
00:02:46,799 --> 00:02:49,349
server twos going to reject this append

54
00:02:49,349 --> 00:02:51,060
entries and sort of send a false reply

55
00:02:51,060 --> 00:02:54,690
back leader and server one doesn't even

56
00:02:54,690 --> 00:02:56,700
have anything here so server ones gonna

57
00:02:56,700 --> 00:03:00,000
also reject the append entries in the

58
00:03:00,000 --> 00:03:03,480
leader and so so far so good right the

59
00:03:03,480 --> 00:03:05,819
terrible thing that that has been

60
00:03:05,819 --> 00:03:08,220
averted at this point is you know the

61
00:03:08,220 --> 00:03:09,989
bad thing we absolutely don't want to

62
00:03:09,989 --> 00:03:12,030
see is that server to actually stuck the

63
00:03:12,030 --> 00:03:15,209
new blog entry in here which would break

64
00:03:15,209 --> 00:03:20,280
sort of inductive proofs essentially

65
00:03:20,280 --> 00:03:24,599
that the figure to scheme relies on and

66
00:03:24,599 --> 00:03:27,359
hide the fact that server two actually

67
00:03:27,359 --> 00:03:28,799
had a different log so instead of

68
00:03:28,799 --> 00:03:30,299
accepting log entry server two projects

69
00:03:30,299 --> 00:03:34,440
this RPC the leader sees is two

70
00:03:34,440 --> 00:03:36,150
rejections and leader is maintaining

71
00:03:36,150 --> 00:03:38,329
this next index field one for each

72
00:03:38,329 --> 00:03:45,199
follower so it has a next index for

73
00:03:45,199 --> 00:03:48,629
server two and the leader has a next

74
00:03:48,629 --> 00:03:54,660
index for server one presumably if the

75
00:03:54,660 --> 00:03:56,129
should have said this before if the

76
00:03:56,129 --> 00:03:58,430
server sending out information about

77
00:03:58,430 --> 00:04:01,889
slot thirteen here that must mean that

78
00:04:01,889 --> 00:04:03,870
the server's next index is for both of

79
00:04:03,870 --> 00:04:09,090
these other servers this started out as

80
00:04:09,090 --> 00:04:11,099
thirteen and that would be the case at

81
00:04:11,099 --> 00:04:13,230
the server if this leader had just

82
00:04:13,230 --> 00:04:14,940
restarted because the figure two rules

83
00:04:14,940 --> 00:04:16,649
say that next index starts out at the

84
00:04:16,649 --> 00:04:21,238
end of the new leaders log and so in

85
00:04:21,238 --> 00:04:23,760
response to errors the leaders supposed

86
00:04:23,760 --> 00:04:25,980
to decrement its next in

87
00:04:25,980 --> 00:04:28,470
steal so it does that for both got

88
00:04:28,470 --> 00:04:34,710
errors from boat deca mr. Calvin resends

89
00:04:34,710 --> 00:04:36,300
and this time the server is going to

90
00:04:36,300 --> 00:04:39,450
send out append entries with previous

91
00:04:39,450 --> 00:04:41,780
log index equals 11

92
00:04:41,780 --> 00:04:47,430
and previous log term equals 3 and this

93
00:04:47,430 --> 00:04:50,340
new append entries has it has a

94
00:04:50,340 --> 00:04:53,250
different previous log index but it's

95
00:04:53,250 --> 00:04:55,800
the content in the log entries that the

96
00:04:55,800 --> 00:04:58,140
server is going to send out this time

97
00:04:58,140 --> 00:05:01,410
include you know all the entries after

98
00:05:01,410 --> 00:05:03,420
that the new previous log index is

99
00:05:03,420 --> 00:05:06,240
sending out so server 2 now the previous

100
00:05:06,240 --> 00:05:10,710
log index 11 it looks there and it sees

101
00:05:10,710 --> 00:05:12,960
a ha you know the term is 3 same as what

102
00:05:12,960 --> 00:05:15,510
the reader is sending me so server 2 is

103
00:05:15,510 --> 00:05:17,220
actually going to accept this append

104
00:05:17,220 --> 00:05:20,520
entries and figure 2 rules say oh if you

105
00:05:20,520 --> 00:05:22,440
accept a pendent we supposed to delete

106
00:05:22,440 --> 00:05:24,030
everything in your log after where the

107
00:05:24,030 --> 00:05:26,040
append entry starts and replace it with

108
00:05:26,040 --> 00:05:28,340
whatever's in the append entries so

109
00:05:28,340 --> 00:05:32,360
server tune is going to do that now it's

110
00:05:32,810 --> 00:05:35,760
he just went to 5 6 server 1 still has a

111
00:05:35,760 --> 00:05:38,580
problem cuz it has nothing at slot 11

112
00:05:38,580 --> 00:05:41,730
middle would return another error the

113
00:05:41,730 --> 00:05:47,730
server will now backup its server 1 next

114
00:05:47,730 --> 00:05:51,240
index 2 11 it'll send out its log

115
00:05:51,240 --> 00:05:54,330
starting here with the previous index

116
00:05:54,330 --> 00:05:56,340
and term referring now to this slot and

117
00:05:56,340 --> 00:05:58,250
this one's actually acceptable server 1

118
00:05:58,250 --> 00:06:00,990
it'll adopt it'll accept the new log

119
00:06:00,990 --> 00:06:03,120
entries and send a positive response

120
00:06:03,120 --> 00:06:06,740
back to the server and now they're all

121
00:06:07,670 --> 00:06:13,880
now they're all caught up and the

122
00:06:14,720 --> 00:06:17,880
presumably the server also when it sees

123
00:06:17,880 --> 00:06:21,420
that followers accepted and append

124
00:06:21,420 --> 00:06:22,920
entries that had a certain number of log

125
00:06:22,920 --> 00:06:24,360
entries it actually increments this next

126
00:06:24,360 --> 00:06:29,070
index could be 14 4 alright so the net

127
00:06:29,070 --> 00:06:31,020
effect of all this backing up is that

128
00:06:31,020 --> 00:06:33,090
the server has used a backup mechanism

129
00:06:33,090 --> 00:06:36,770
to detect the point at which the

130
00:06:36,770 --> 00:06:38,370
followers logs

131
00:06:38,370 --> 00:06:39,760
started to be equal to this

132
00:06:39,760 --> 00:06:42,430
servers and then sent each of the

133
00:06:42,430 --> 00:06:43,900
followers starting from that point that

134
00:06:43,900 --> 00:06:47,280
a complete remainder of the server's log

135
00:06:47,280 --> 00:06:49,810
after that last point at which they were

136
00:06:49,810 --> 00:07:01,890
equal any questions all right

137
00:07:01,920 --> 00:07:05,740
just to repeat discussion we've had

138
00:07:05,740 --> 00:07:07,990
before and we'll probably have again you

139
00:07:07,990 --> 00:07:09,790
notice that we erased some blog entries

140
00:07:09,790 --> 00:07:11,740
here which are now su erase that I

141
00:07:11,740 --> 00:07:15,010
forget what they were 4 & 5 so there

142
00:07:15,010 --> 00:07:18,570
were some well actually that was mostly

143
00:07:18,570 --> 00:07:21,310
remember we erased this log entry here

144
00:07:21,310 --> 00:07:24,760
this used to say for um server - the

145
00:07:24,760 --> 00:07:27,460
question is why was it ok for the system

146
00:07:27,460 --> 00:07:29,440
to forget about this client command

147
00:07:29,440 --> 00:07:32,170
right this thing we erased corresponds

148
00:07:32,170 --> 00:07:33,370
to some client command which are now

149
00:07:33,370 --> 00:07:36,970
throwing away I talked about this

150
00:07:36,970 --> 00:07:42,790
yesterday what's the rationale here yeah

151
00:07:42,790 --> 00:07:45,040
so it's not a majority of the servers

152
00:07:45,040 --> 00:07:46,720
and therefore whatever previous leader

153
00:07:46,720 --> 00:07:49,300
it was who sent this out couldn't have

154
00:07:49,300 --> 00:07:51,310
gotten acknowledgments from a majority

155
00:07:51,310 --> 00:07:52,810
of servers therefore that previous

156
00:07:52,810 --> 00:07:55,240
leader couldn't have decided it was

157
00:07:55,240 --> 00:07:57,400
committed couldn't have executed it and

158
00:07:57,400 --> 00:07:58,930
applied it to the application state

159
00:07:58,930 --> 00:08:00,970
could never have sent a positive reply

160
00:08:00,970 --> 00:08:03,580
back to the client so because this isn't

161
00:08:03,580 --> 00:08:05,320
done a majority of servers we know that

162
00:08:05,320 --> 00:08:07,060
the client who send in and has no reason

163
00:08:07,060 --> 00:08:08,860
to believe it was executed couldn't have

164
00:08:08,860 --> 00:08:10,240
gotten a reply because one of the rules

165
00:08:10,240 --> 00:08:12,940
is the server only sends over the leader

166
00:08:12,940 --> 00:08:15,070
only sends a reply to a client after it

167
00:08:15,070 --> 00:08:19,090
commits and executes so the client had

168
00:08:19,090 --> 00:08:20,380
no reason to believe it was even

169
00:08:20,380 --> 00:08:23,380
received by any server and then and the

170
00:08:23,380 --> 00:08:24,730
rules of figure to basically say the

171
00:08:24,730 --> 00:08:26,590
client if he gets no response after a

172
00:08:26,590 --> 00:08:27,880
while it supposed to resend the request

173
00:08:27,880 --> 00:08:29,800
so we know whatever request this was it

174
00:08:29,800 --> 00:08:33,700
threw away we've never executed never

175
00:08:33,700 --> 00:08:36,039
included in any state already and the

176
00:08:36,039 --> 00:08:41,159
clients gonna resend it by-and-by yes

177
00:08:58,440 --> 00:09:03,460
well it's always deleting suffix of the

178
00:09:03,460 --> 00:09:08,290
followers log I mean in the end the sort

179
00:09:08,290 --> 00:09:10,750
of backup answer to this is that the

180
00:09:10,750 --> 00:09:13,840
leader has a complete log so all its

181
00:09:13,840 --> 00:09:16,510
fails it can just send us complete log

182
00:09:16,510 --> 00:09:19,270
to the follower and indeed if you know

183
00:09:19,270 --> 00:09:20,590
if you've just started up the system and

184
00:09:20,590 --> 00:09:22,390
something very strange happened even at

185
00:09:22,390 --> 00:09:24,880
the very beginning then you may end up

186
00:09:24,880 --> 00:09:26,140
actually you know maybe in some of the

187
00:09:26,140 --> 00:09:28,780
tests for lab two you may end up backing

188
00:09:28,780 --> 00:09:31,330
up to the very first entry and then

189
00:09:31,330 --> 00:09:32,920
having the leader essentially send the

190
00:09:32,920 --> 00:09:34,180
whole log but because the leader has

191
00:09:34,180 --> 00:09:35,620
this whole law we know it could sort of

192
00:09:35,620 --> 00:09:37,330
it's got all the information that's

193
00:09:37,330 --> 00:09:40,330
required to feel everybody's logs if it

194
00:09:40,330 --> 00:09:42,570
needs to

195
00:09:49,260 --> 00:09:53,950
okay all right so in this example which

196
00:09:53,950 --> 00:09:57,850
I guess are now erased we elected s3 as

197
00:09:57,850 --> 00:10:02,680
the leader and the question is could we

198
00:10:02,680 --> 00:10:04,870
you know who can we who are we allowed

199
00:10:04,870 --> 00:10:08,830
to elect this leader right cool

200
00:10:08,830 --> 00:10:10,840
you know that all right if you read the

201
00:10:10,840 --> 00:10:12,730
paper you know the answer is not just

202
00:10:12,730 --> 00:10:15,670
anyone it turns out it matters a lot for

203
00:10:15,670 --> 00:10:17,410
the correctness the correctness of the

204
00:10:17,410 --> 00:10:19,900
system that we don't allow just anyone

205
00:10:19,900 --> 00:10:21,670
to be the leader like for example the

206
00:10:21,670 --> 00:10:24,610
first node whose timer goes off may in

207
00:10:24,610 --> 00:10:28,150
fact not be an acceptable leader and so

208
00:10:28,150 --> 00:10:29,800
it turns out raft has some rules that

209
00:10:29,800 --> 00:10:32,620
applies about oh yes you can be leader

210
00:10:32,620 --> 00:10:35,440
or you can't be leader and to see why

211
00:10:35,440 --> 00:10:37,000
this is true let's sort of set up a

212
00:10:37,000 --> 00:10:43,090
straw man proposal that maybe raft

213
00:10:43,090 --> 00:10:46,120
should accept should use the server with

214
00:10:46,120 --> 00:10:49,210
the longest log as the leader right you

215
00:10:49,210 --> 00:10:50,830
know some alternate universe that could

216
00:10:50,830 --> 00:10:52,420
be true and it is actually true in

217
00:10:52,420 --> 00:10:55,000
systems with different designs just not

218
00:10:55,000 --> 00:10:57,340
in raft so the question we're

219
00:10:57,340 --> 00:11:02,260
investigating is why not use the

220
00:11:02,260 --> 00:11:09,910
cervical longest law as leader and this

221
00:11:09,910 --> 00:11:11,710
would involve changing the voting rules

222
00:11:11,710 --> 00:11:16,090
in raft have a voters only vote for

223
00:11:16,090 --> 00:11:19,600
nodes that have longer logs all right so

224
00:11:19,600 --> 00:11:21,610
the example that's going to be

225
00:11:21,610 --> 00:11:23,080
convenient for showing why this is a bad

226
00:11:23,080 --> 00:11:25,900
idea so let's imagine we have three

227
00:11:25,900 --> 00:11:29,980
servers again and now the log set setups

228
00:11:29,980 --> 00:11:34,360
are server Wan has entries for terms

229
00:11:34,360 --> 00:11:38,530
five six and seven server two four five

230
00:11:38,530 --> 00:11:41,950
and eight and server three also four

231
00:11:41,950 --> 00:11:46,900
five and eight that's the first question

232
00:11:46,900 --> 00:11:50,020
of course to avoid spending our time

233
00:11:50,020 --> 00:11:51,610
scratching our heads about utter

234
00:11:51,610 --> 00:11:54,520
nonsense is to make sure that convince

235
00:11:54,520 --> 00:11:56,320
ourselves that this configuration could

236
00:11:56,320 --> 00:11:58,060
actually arise because if it couldn't

237
00:11:58,060 --> 00:11:59,800
possibly arise then

238
00:11:59,800 --> 00:12:01,390
may be a waste of time to figure out

239
00:12:01,390 --> 00:12:03,760
what would happen if it did arise so

240
00:12:03,760 --> 00:12:07,630
anybody wanna propose a sequence of

241
00:12:07,630 --> 00:12:10,779
events whereby this set of logs could

242
00:12:10,779 --> 00:12:17,140
have arisen how about an argument that

243
00:12:17,140 --> 00:12:27,160
it couldn't have arisen oh yeah okay so

244
00:12:27,160 --> 00:12:31,650
well maybe we'll back up sometime

245
00:12:31,800 --> 00:12:34,450
all right so server one wins is wins the

246
00:12:34,450 --> 00:12:37,150
election at this point and it's in term

247
00:12:37,150 --> 00:12:42,520
six sends out yeah it receives a client

248
00:12:42,520 --> 00:12:44,020
request sends out the first append

249
00:12:44,020 --> 00:12:52,900
entries and then that's fine actually

250
00:12:52,900 --> 00:12:56,160
everything's fine so far nothing's wrong

251
00:12:56,790 --> 00:12:59,770
all right well a good bet for all these

252
00:12:59,770 --> 00:13:01,960
things is then it crashes right or it

253
00:13:01,960 --> 00:13:04,990
receives the client requests in term six

254
00:13:04,990 --> 00:13:06,790
it appends the client requests to its

255
00:13:06,790 --> 00:13:08,589
own log which it does first and it's

256
00:13:08,589 --> 00:13:10,270
about to send out a pen entries but it

257
00:13:10,270 --> 00:13:12,760
crashes yes it didn't send out any pen

258
00:13:12,760 --> 00:13:14,770
entries and then you know we need then

259
00:13:14,770 --> 00:13:16,510
it crashes and restarts very quickly

260
00:13:16,510 --> 00:13:19,360
there's a new election and gosh server

261
00:13:19,360 --> 00:13:22,089
one is elected again as the as the new

262
00:13:22,089 --> 00:13:24,460
leader it receives in term seven and

263
00:13:24,460 --> 00:13:25,839
receives a client request appends it to

264
00:13:25,839 --> 00:13:33,220
its log and then it crashes right and

265
00:13:33,220 --> 00:13:35,380
then after after a crashes we have a new

266
00:13:35,380 --> 00:13:37,360
election maybe server 2 gets elected

267
00:13:37,360 --> 00:13:42,580
this time maybe server 1 is down now so

268
00:13:42,580 --> 00:13:45,970
off the table if server 2 is elected at

269
00:13:45,970 --> 00:13:48,910
this point suppose server 1 is still

270
00:13:48,910 --> 00:13:51,339
dead what term is server what server two

271
00:13:51,339 --> 00:13:53,550
venues

272
00:13:56,420 --> 00:13:58,310
yeah eights the right answer so why

273
00:13:58,310 --> 00:14:00,710
eight and not remember this you know

274
00:14:00,710 --> 00:14:04,570
this is now gone why eight and not six

275
00:14:07,240 --> 00:14:09,620
that's absolutely right so not written

276
00:14:09,620 --> 00:14:11,270
on the board but in order for server one

277
00:14:11,270 --> 00:14:12,740
to have been elected here it must have

278
00:14:12,740 --> 00:14:14,150
votes from majority of nodes which

279
00:14:14,150 --> 00:14:16,690
include at least one of server-to-server

280
00:14:16,690 --> 00:14:21,100
three if you look at the vote request

281
00:14:21,100 --> 00:14:24,380
code and figure two if you vote for

282
00:14:24,380 --> 00:14:25,640
somebody you're you're supposed to

283
00:14:25,640 --> 00:14:30,010
record the term in persistent storage

284
00:14:30,010 --> 00:14:32,900
and that means that either server 2 or

285
00:14:32,900 --> 00:14:35,150
server 3 are both new about term six and

286
00:14:35,150 --> 00:14:38,030
in fact term seven and therefore when

287
00:14:38,030 --> 00:14:39,710
sever one dies and they cannot elect a

288
00:14:39,710 --> 00:14:41,750
new leader at least one of them knows

289
00:14:41,750 --> 00:14:44,930
that the current term was eight if that

290
00:14:44,930 --> 00:14:48,020
one and only that one actually if

291
00:14:48,020 --> 00:14:49,100
there's only one of them only that one

292
00:14:49,100 --> 00:14:51,230
could win an election because it has the

293
00:14:51,230 --> 00:14:52,400
higher terminal birth they both know

294
00:14:52,400 --> 00:14:53,840
about term eight sorry if they both know

295
00:14:53,840 --> 00:14:56,150
about term seven then they'll both and

296
00:14:56,150 --> 00:14:57,740
either one of them will try to be leader

297
00:14:57,740 --> 00:15:00,530
and term eight so that fact of that the

298
00:15:00,530 --> 00:15:02,960
next term must be term a dis is insured

299
00:15:02,960 --> 00:15:05,090
by the property of the majorities must

300
00:15:05,090 --> 00:15:08,060
overlap and the fact that current term

301
00:15:08,060 --> 00:15:10,490
is updated by vote request and is

302
00:15:10,490 --> 00:15:12,710
persistent and guarantee did not be lost

303
00:15:12,710 --> 00:15:14,810
even if there were some crashes here so

304
00:15:14,810 --> 00:15:15,650
the next term is going to be eight

305
00:15:15,650 --> 00:15:17,360
server two or server three will win the

306
00:15:17,360 --> 00:15:19,490
leadership election and let's just

307
00:15:19,490 --> 00:15:21,350
imagine that whichever one it is sends

308
00:15:21,350 --> 00:15:25,820
out append entries for a new client

309
00:15:25,820 --> 00:15:27,380
requests the other one gets it and so

310
00:15:27,380 --> 00:15:30,020
now we have this configuration right so

311
00:15:30,020 --> 00:15:32,630
I was a bit of a detour we're back to

312
00:15:32,630 --> 00:15:36,080
our original question of in this

313
00:15:36,080 --> 00:15:38,150
configuration suppose server one revives

314
00:15:38,150 --> 00:15:42,860
we have an election would it be okay to

315
00:15:42,860 --> 00:15:44,720
use server one would it be okay to have

316
00:15:44,720 --> 00:15:48,890
the rule be the longest log wins the

317
00:15:48,890 --> 00:15:54,290
longest log gets to be the leader yeah

318
00:15:54,290 --> 00:15:56,690
obviously not right because server was a

319
00:15:56,690 --> 00:16:04,460
leader did it's going to force its log

320
00:16:04,460 --> 00:16:07,250
on to the to followers by the append

321
00:16:07,250 --> 00:16:08,570
entries machinery that we just talked

322
00:16:08,570 --> 00:16:09,950
about a few minutes ago

323
00:16:09,950 --> 00:16:11,390
if we live server one to be the leader

324
00:16:11,390 --> 00:16:13,850
it's gonna you know sent out a pen

325
00:16:13,850 --> 00:16:15,710
entries whatever backup overwrite these

326
00:16:15,710 --> 00:16:19,040
aids tell the followers to erase their

327
00:16:19,040 --> 00:16:21,470
log entries for term a to accept to

328
00:16:21,470 --> 00:16:23,480
overwrite them with this six and seven

329
00:16:23,480 --> 00:16:26,080
log entries and then to proceed now with

330
00:16:26,080 --> 00:16:30,380
identical to server ones so of course

331
00:16:30,380 --> 00:16:39,860
why are we upset about this yeah yeah

332
00:16:39,860 --> 00:16:43,070
exactly it was already committed right

333
00:16:43,070 --> 00:16:45,410
it's not a majority of servers has

334
00:16:45,410 --> 00:16:50,060
already committed probably executed

335
00:16:50,060 --> 00:16:52,670
quite possibly a reply sent to a client

336
00:16:52,670 --> 00:16:56,510
so we're not entitled to delete it and

337
00:16:56,510 --> 00:17:00,110
therefore server one cannot be allowed

338
00:17:00,110 --> 00:17:02,660
to become leader and force its log onto

339
00:17:02,660 --> 00:17:06,170
servers two and three everybody see why

340
00:17:06,170 --> 00:17:12,050
that's bad idea for rapid and because of

341
00:17:12,050 --> 00:17:15,920
that this can't possibly have been rule

342
00:17:15,920 --> 00:17:19,970
for elections of course shortest log

343
00:17:19,970 --> 00:17:23,780
didn't work too well either and so in

344
00:17:23,780 --> 00:17:26,900
fact if you read forward to section

345
00:17:26,900 --> 00:17:31,300
something five point four point one

346
00:17:32,950 --> 00:17:34,910
draft actually has a slightly more

347
00:17:34,910 --> 00:17:41,380
sophisticated election restriction that

348
00:17:43,960 --> 00:17:47,120
the request vote handling RPC handling

349
00:17:47,120 --> 00:17:49,520
code is supposed to check before it says

350
00:17:49,520 --> 00:17:51,740
yes before votes yes for a different

351
00:17:51,740 --> 00:18:00,050
peer and the rule is we only vote you

352
00:18:00,050 --> 00:18:02,630
vote yes for some candidate who send us

353
00:18:02,630 --> 00:18:10,730
over request votes only if candidate has

354
00:18:10,730 --> 00:18:13,990
a higher

355
00:18:15,050 --> 00:18:26,809
term in the last log entry or same last

356
00:18:26,809 --> 00:18:31,450
term same charming the last log entry

357
00:18:31,450 --> 00:18:38,090
and a log length that's greater than or

358
00:18:38,090 --> 00:18:44,720
equal to the the server that received

359
00:18:44,720 --> 00:18:51,740
that received the boat request and so if

360
00:18:51,740 --> 00:18:53,840
we apply this here if server two gets a

361
00:18:53,840 --> 00:18:58,400
vote request from server one there our

362
00:18:58,400 --> 00:19:03,410
last log entry terms or seven the server

363
00:19:03,410 --> 00:19:04,670
one's gonna send out a request votes

364
00:19:04,670 --> 00:19:08,150
with a last entry term whatever of 7

365
00:19:08,150 --> 00:19:11,920
server twos is eight so this isn't true

366
00:19:11,920 --> 00:19:14,900
server service we didn't get a request

367
00:19:14,900 --> 00:19:16,370
from somebody with a higher term in the

368
00:19:16,370 --> 00:19:22,220
last entry and or the last entry terms

369
00:19:22,220 --> 00:19:23,480
aren't the same either said the second

370
00:19:23,480 --> 00:19:26,540
Clause doesn't apply either so neither

371
00:19:26,540 --> 00:19:28,460
server to new serve nor server three is

372
00:19:28,460 --> 00:19:30,470
going to vote for server one and so even

373
00:19:30,470 --> 00:19:32,240
if it sends out this vote requests first

374
00:19:32,240 --> 00:19:33,650
because this has a shorter election

375
00:19:33,650 --> 00:19:35,510
timeout nobody's going to vote for it

376
00:19:35,510 --> 00:19:36,830
except itself so I don't think it's one

377
00:19:36,830 --> 00:19:38,900
vote it's not a majority if either

378
00:19:38,900 --> 00:19:41,900
server two or server three becomes a

379
00:19:41,900 --> 00:19:44,630
candidate then either of them will

380
00:19:44,630 --> 00:19:45,920
accept the other because they have the

381
00:19:45,920 --> 00:19:48,260
same last term number and their logs are

382
00:19:48,260 --> 00:19:50,000
each greater than or equal to in length

383
00:19:50,000 --> 00:19:52,280
and the others so either of them will

384
00:19:52,280 --> 00:19:55,040
vote for for the other one will server

385
00:19:55,040 --> 00:19:56,920
one vote for either of them

386
00:19:56,920 --> 00:20:00,140
yes because either server 2 or server 3

387
00:20:00,140 --> 00:20:01,370
has a higher term number in the last

388
00:20:01,370 --> 00:20:05,960
entry so you know what this is doing is

389
00:20:05,960 --> 00:20:07,940
making sure that you can only become a

390
00:20:07,940 --> 00:20:11,780
candidate if or it prefers candidates

391
00:20:11,780 --> 00:20:13,460
that knew about higher that have log

392
00:20:13,460 --> 00:20:15,710
entries some higher terms that is it

393
00:20:15,710 --> 00:20:17,090
prefers candidates that are more likely

394
00:20:17,090 --> 00:20:18,679
to have been receiving log entries from

395
00:20:18,679 --> 00:20:23,750
the previous leader and you know this

396
00:20:23,750 --> 00:20:25,400
second part says well we were all

397
00:20:25,400 --> 00:20:26,809
listening to the previous leader then

398
00:20:26,809 --> 00:20:27,380
we're going to

399
00:20:27,380 --> 00:20:30,500
for the server that has saw more

400
00:20:30,500 --> 00:20:35,540
requests from the very last leader any

401
00:20:35,540 --> 00:20:40,510
questions about the election restriction

402
00:20:45,520 --> 00:20:55,070
okay final thing about sending out log

403
00:20:55,070 --> 00:20:59,510
entries is that this rollback scheme at

404
00:20:59,510 --> 00:21:01,460
least as I described it and it's as its

405
00:21:01,460 --> 00:21:03,679
described in Figure two rolls back one

406
00:21:03,679 --> 00:21:08,030
log entry at a time and you know

407
00:21:08,030 --> 00:21:09,559
probably a lot of fun that's okay

408
00:21:09,559 --> 00:21:13,100
but there are situations maybe in the

409
00:21:13,100 --> 00:21:15,290
real world and definitely in the lab

410
00:21:15,290 --> 00:21:18,530
tests where backing up one entry at a

411
00:21:18,530 --> 00:21:20,120
time is going to take a long long time

412
00:21:20,120 --> 00:21:22,400
and so the real-world situation where

413
00:21:22,400 --> 00:21:25,820
that might be true is if they if a

414
00:21:25,820 --> 00:21:27,950
follower has been down for a long time

415
00:21:27,950 --> 00:21:30,170
and missed a lot of upend entries and

416
00:21:30,170 --> 00:21:33,110
the leader restarts and if you follow

417
00:21:33,110 --> 00:21:34,670
the pseudocode in Figure two if a leader

418
00:21:34,670 --> 00:21:36,230
restarts is supposed to set its next

419
00:21:36,230 --> 00:21:38,570
index to the end of the leaders log so

420
00:21:38,570 --> 00:21:40,190
if the follower has been down and you

421
00:21:40,190 --> 00:21:42,559
know miss the last thousand log entries

422
00:21:42,559 --> 00:21:45,620
and leader reboots the leader is gonna

423
00:21:45,620 --> 00:21:48,350
have to walk back off one at a time one

424
00:21:48,350 --> 00:21:50,960
RPC at a time all thousand of those log

425
00:21:50,960 --> 00:21:53,840
entries that the follower missed and

426
00:21:53,840 --> 00:21:55,190
there's no you know particular reason

427
00:21:55,190 --> 00:21:57,590
why this would never happen in real life

428
00:21:57,590 --> 00:22:01,160
it could easily happen at somewhat more

429
00:22:01,160 --> 00:22:03,950
contrived situation that the tests are

430
00:22:03,950 --> 00:22:07,190
definitely explorers is if a follower is

431
00:22:07,190 --> 00:22:09,890
if we say we have five servers and

432
00:22:09,890 --> 00:22:13,910
there's there's a leader but the leaders

433
00:22:13,910 --> 00:22:17,000
got trapped with one follower in a

434
00:22:17,000 --> 00:22:18,440
network partition but the leader doesn't

435
00:22:18,440 --> 00:22:19,790
know it's not leader anymore and it's

436
00:22:19,790 --> 00:22:21,920
still sending out append entries to its

437
00:22:21,920 --> 00:22:23,150
one follower and none of which are

438
00:22:23,150 --> 00:22:25,940
committed while in the other majority

439
00:22:25,940 --> 00:22:28,730
partition the system is continuing as

440
00:22:28,730 --> 00:22:32,500
usual the ex leader and follower in that

441
00:22:32,500 --> 00:22:35,690
Minority partition could end up putting

442
00:22:35,690 --> 00:22:37,490
in their logs you know sort of unlimited

443
00:22:37,490 --> 00:22:40,790
numbers of log entries for a stale term

444
00:22:40,790 --> 00:22:42,260
that will never be committed and need to

445
00:22:42,260 --> 00:22:44,240
be deleted and overwritten eventually

446
00:22:44,240 --> 00:22:47,600
when they rejoin the main group that's

447
00:22:47,600 --> 00:22:48,740
maybe a little less likely in the real

448
00:22:48,740 --> 00:22:52,520
world but you'll see it happen and the

449
00:22:52,520 --> 00:22:55,280
test set up so in order to be able to

450
00:22:55,280 --> 00:22:57,610
back up faster that paper has

451
00:22:57,610 --> 00:22:59,950
somewhat a vague description of a faster

452
00:22:59,950 --> 00:23:05,010
scheme towards the end of section 5.3

453
00:23:05,010 --> 00:23:07,300
it's a little bit hard to interpret so

454
00:23:07,300 --> 00:23:10,150
I'm gonna try to explain what their

455
00:23:10,150 --> 00:23:11,650
ideas about how to back up faster a

456
00:23:11,650 --> 00:23:13,270
little bit better and the general idea

457
00:23:13,270 --> 00:23:15,520
is to be able to to have the follower

458
00:23:15,520 --> 00:23:17,380
send enough information to the leader

459
00:23:17,380 --> 00:23:19,630
that the leader can jump back an entire

460
00:23:19,630 --> 00:23:22,960
terms worth of entries that have to be

461
00:23:22,960 --> 00:23:26,140
deleted per append entries so it leader

462
00:23:26,140 --> 00:23:27,580
may only have to send one in a pennant

463
00:23:27,580 --> 00:23:30,880
and append entries per term in which the

464
00:23:30,880 --> 00:23:33,850
leader and follower disagree instead of

465
00:23:33,850 --> 00:23:38,080
one per entry so there's three cases I

466
00:23:38,080 --> 00:23:39,910
think are important and the fact is that

467
00:23:39,910 --> 00:23:42,960
you can probably think of many different

468
00:23:42,960 --> 00:23:46,620
log backup acceleration strategies and

469
00:23:46,620 --> 00:23:50,170
here's one so I'm going to divide the

470
00:23:50,170 --> 00:23:51,880
kinds of situations you might see into

471
00:23:51,880 --> 00:24:01,480
three cases so this is fast backup case

472
00:24:01,480 --> 00:24:06,940
one I'm just going to talk about one

473
00:24:06,940 --> 00:24:09,280
follower and the leader and not worry

474
00:24:09,280 --> 00:24:12,100
about the other nodes the same we have

475
00:24:12,100 --> 00:24:18,040
two server one which is the follower and

476
00:24:18,040 --> 00:24:25,570
server 2 which is the leader so this is

477
00:24:25,570 --> 00:24:29,080
one case and here we need to backup over

478
00:24:29,080 --> 00:24:31,030
a term where that term is entirely

479
00:24:31,030 --> 00:24:39,600
missing from the leader another case

480
00:24:44,640 --> 00:24:47,680
so in this case we need to back up over

481
00:24:47,680 --> 00:24:49,180
some entries but their entries for a

482
00:24:49,180 --> 00:24:50,410
term that the leader actually knows

483
00:24:50,410 --> 00:24:53,980
about so apparently the this followers

484
00:24:53,980 --> 00:24:56,800
saw a couple of entry a couple of the

485
00:24:56,800 --> 00:24:58,960
very Flass few append entries sent out

486
00:24:58,960 --> 00:25:01,900
by a leader that was about to crash but

487
00:25:01,900 --> 00:25:03,640
the new leader didn't see them we still

488
00:25:03,640 --> 00:25:05,860
need to back up over them and a third

489
00:25:05,860 --> 00:25:11,680
case is where the followers entirely

490
00:25:11,680 --> 00:25:15,210
missing the following the leader agree

491
00:25:15,210 --> 00:25:19,900
but the followers is missing the end of

492
00:25:19,900 --> 00:25:24,790
the leaders log and I believe you can

493
00:25:24,790 --> 00:25:27,210
take care of all three of these with

494
00:25:27,210 --> 00:25:29,920
three pieces of extra information in the

495
00:25:29,920 --> 00:25:32,140
reply that a follower sends back to the

496
00:25:32,140 --> 00:25:35,590
leader in the case in the append entries

497
00:25:35,590 --> 00:25:37,300
so we're talking about the append

498
00:25:37,300 --> 00:25:42,220
entries reply if the follower rejects

499
00:25:42,220 --> 00:25:43,930
the append entries because the logs

500
00:25:43,930 --> 00:25:46,210
don't agree there's three pieces of

501
00:25:46,210 --> 00:25:47,500
information that will be useful and

502
00:25:47,500 --> 00:25:49,990
taking care of three street cases I'll

503
00:25:49,990 --> 00:25:55,450
call them X term which is the term of

504
00:25:55,450 --> 00:25:58,300
the conflicting entry I remember the

505
00:25:58,300 --> 00:26:05,460
leader sent this previous log term and

506
00:26:05,460 --> 00:26:07,810
if the follower rejects it because it

507
00:26:07,810 --> 00:26:09,040
has something here but the terms wrong

508
00:26:09,040 --> 00:26:12,880
so it'll put the followers term for the

509
00:26:12,880 --> 00:26:19,330
conflicting entry here or you know I'm

510
00:26:19,330 --> 00:26:21,040
negative one or something it doesn't

511
00:26:21,040 --> 00:26:25,030
have anything in the log there it'll

512
00:26:25,030 --> 00:26:30,220
also send back the index of the

513
00:26:30,220 --> 00:26:33,310
conflicting but the index are the first

514
00:26:33,310 --> 00:26:36,240
entry with that term

515
00:26:46,750 --> 00:26:49,840
and finally if there wasn't any log

516
00:26:49,840 --> 00:26:52,750
entry there at all the follower will

517
00:26:52,750 --> 00:26:56,860
send back on the length of its law like

518
00:26:56,860 --> 00:27:02,470
the followers log so for case one the

519
00:27:02,470 --> 00:27:12,790
way this helps if the it's a leader sees

520
00:27:12,790 --> 00:27:16,150
that the leader doesn't even have an

521
00:27:16,150 --> 00:27:19,030
entry with X term of term X term at all

522
00:27:19,030 --> 00:27:22,870
in its log so that's this case where the

523
00:27:22,870 --> 00:27:24,400
leader didn't have turn five and if the

524
00:27:24,400 --> 00:27:26,260
leader can simply back up to the

525
00:27:26,260 --> 00:27:30,570
beginning of the followers run of

526
00:27:30,570 --> 00:27:34,020
entries with X term that is the the

527
00:27:34,020 --> 00:27:37,000
leader can set its next index to this X

528
00:27:37,000 --> 00:27:41,650
index thing which is the first entry the

529
00:27:41,650 --> 00:27:45,179
followers run of items from term five

530
00:27:45,179 --> 00:27:48,460
alright so if the leader doesn't have X

531
00:27:48,460 --> 00:27:51,070
term at all it should back up to X back

532
00:27:51,070 --> 00:27:53,710
the follower up to X index the second

533
00:27:53,710 --> 00:27:55,570
case you can detect the fault the leader

534
00:27:55,570 --> 00:27:59,770
can detect if X term is valid and the

535
00:27:59,770 --> 00:28:04,900
leader actually has log entries of term

536
00:28:04,900 --> 00:28:08,280
X term that's the case here where the

537
00:28:08,280 --> 00:28:10,510
you know the disagreement is here but

538
00:28:10,510 --> 00:28:12,820
the leader actually has some entries

539
00:28:12,820 --> 00:28:14,890
that term in that case the leader should

540
00:28:14,890 --> 00:28:18,510
back up to the last entry it has that

541
00:28:18,510 --> 00:28:22,929
has the contesta followers term for the

542
00:28:22,929 --> 00:28:24,790
conflicting term in it that is the last

543
00:28:24,790 --> 00:28:26,919
entry that a leader has for term for in

544
00:28:26,919 --> 00:28:29,710
this case and if neither of these two

545
00:28:29,710 --> 00:28:33,130
cases hold that is the well actually if

546
00:28:33,130 --> 00:28:36,010
the follower indicates by maybe setting

547
00:28:36,010 --> 00:28:37,660
X term to minus one it actually didn't

548
00:28:37,660 --> 00:28:39,520
have anything whatsoever at the

549
00:28:39,520 --> 00:28:41,919
conflicting log and index because it's

550
00:28:41,919 --> 00:28:46,960
log is too short then the leader should

551
00:28:46,960 --> 00:28:49,780
back up its next index to the last entry

552
00:28:49,780 --> 00:28:51,400
that the follower had at all and start

553
00:28:51,400 --> 00:28:53,840
sending from there

554
00:28:53,840 --> 00:28:55,830
and I'm telling you this because it'll

555
00:28:55,830 --> 00:29:00,650
be useful for doing a lab and if you

556
00:29:00,650 --> 00:29:03,090
miss some of my description it's it's in

557
00:29:03,090 --> 00:29:05,130
electronics then any questions about

558
00:29:05,130 --> 00:29:20,970
this backing up business Jack I think

559
00:29:20,970 --> 00:29:25,080
that's true yeah yeah yeah maybe binary

560
00:29:25,080 --> 00:29:26,880
search I'm not ruling out other

561
00:29:26,880 --> 00:29:29,610
solutions I mean that you know after

562
00:29:29,610 --> 00:29:32,130
reading the papers non description of

563
00:29:32,130 --> 00:29:34,470
how to do it I like cook this up and

564
00:29:34,470 --> 00:29:37,530
there's probably other ways to do this

565
00:29:37,530 --> 00:29:39,060
probably better ways and faster ways of

566
00:29:39,060 --> 00:29:40,590
doing it like I'm I'm sure that if

567
00:29:40,590 --> 00:29:41,880
you're willing to send back more

568
00:29:41,880 --> 00:29:43,890
information or have a more sophisticated

569
00:29:43,890 --> 00:29:46,020
strategy like binary search you can do a

570
00:29:46,020 --> 00:29:50,550
better job yeah well you you almost

571
00:29:50,550 --> 00:29:53,150
certainly need to do something

572
00:29:53,150 --> 00:29:55,140
experience suggests that in order to

573
00:29:55,140 --> 00:29:57,600
pass the tests you'll need to do

574
00:29:57,600 --> 00:30:02,040
something to as well probably not me

575
00:30:02,040 --> 00:30:04,950
although I that's not quite true like

576
00:30:04,950 --> 00:30:06,420
one of the solutions I've written over

577
00:30:06,420 --> 00:30:08,550
the years actually does the stupid thing

578
00:30:08,550 --> 00:30:11,490
and still passes the tests but because

579
00:30:11,490 --> 00:30:15,990
the tests you know the one of the sort

580
00:30:15,990 --> 00:30:17,430
of unfortunate but inevitable things

581
00:30:17,430 --> 00:30:19,410
about the tests we give you is that they

582
00:30:19,410 --> 00:30:21,660
have a bit of a real time requirement

583
00:30:21,660 --> 00:30:23,250
that is the tests are not willing to

584
00:30:23,250 --> 00:30:25,590
wait forever for your solution to

585
00:30:25,590 --> 00:30:29,370
produce an answer so it is possible to

586
00:30:29,370 --> 00:30:30,720
have a solution that's you know

587
00:30:30,720 --> 00:30:33,930
technically correct but takes so long

588
00:30:33,930 --> 00:30:36,710
that the tester gives up and

589
00:30:36,710 --> 00:30:39,060
unfortunately you know we will the

590
00:30:39,060 --> 00:30:40,830
tester will fail you if your solution

591
00:30:40,830 --> 00:30:42,810
doesn't finish the test and whatever the

592
00:30:42,810 --> 00:30:44,790
time limit is and therefore you do

593
00:30:44,790 --> 00:30:46,940
actually have to pay some attention to

594
00:30:46,940 --> 00:30:50,460
performance in order you know your

595
00:30:50,460 --> 00:30:52,470
solution has to be both correct and have

596
00:30:52,470 --> 00:30:54,090
enough performance to finish before the

597
00:30:54,090 --> 00:30:56,490
tester gets bored and sometimes out on

598
00:30:56,490 --> 00:30:58,260
you which is like 10 minutes or I don't

599
00:30:58,260 --> 00:31:00,390
know what it is and unfortunately it's

600
00:31:00,390 --> 00:31:02,280
relatively this stuff's complex enough

601
00:31:02,280 --> 00:31:04,650
that it's not that hard to write a color

602
00:31:04,650 --> 00:31:05,210
correction

603
00:31:05,210 --> 00:31:15,350
that's not fast enough yes so the way

604
00:31:15,350 --> 00:31:16,850
you can tap the leader can tell the

605
00:31:16,850 --> 00:31:20,720
difference is that the follower we're

606
00:31:20,720 --> 00:31:23,120
supposed to send back the term number it

607
00:31:23,120 --> 00:31:25,730
sees in the conflicting entry you we

608
00:31:25,730 --> 00:31:29,120
have case one if the leader does not

609
00:31:29,120 --> 00:31:31,360
have that term in its log

610
00:31:31,360 --> 00:31:34,880
so here the follower will set X term to

611
00:31:34,880 --> 00:31:37,580
five to five because this is this is

612
00:31:37,580 --> 00:31:39,919
going to be the this is gonna be the

613
00:31:39,919 --> 00:31:44,210
conflicting entry the follower says this

614
00:31:44,210 --> 00:31:46,370
X term to five the leader observes oh I

615
00:31:46,370 --> 00:31:48,740
do not have term five in my log and

616
00:31:48,740 --> 00:31:57,200
therefore this case one and you know it

617
00:31:57,200 --> 00:31:58,100
should back up to the beginning

618
00:31:58,100 --> 00:32:00,169
like it doesn't follower hasn't leader

619
00:32:00,169 --> 00:32:02,539
has none of those and term five entry so

620
00:32:02,539 --> 00:32:04,130
it should just get rid of all of them in

621
00:32:04,130 --> 00:32:05,779
the follower by backing up to the

622
00:32:05,779 --> 00:32:20,120
beginning which is X index yeah yeah

623
00:32:20,120 --> 00:32:22,490
because the leaders gonna back up its

624
00:32:22,490 --> 00:32:25,909
next index to here and then send an

625
00:32:25,909 --> 00:32:28,039
append entries that starts here and the

626
00:32:28,039 --> 00:32:29,899
rules a figure to say ah the follower

627
00:32:29,899 --> 00:32:31,940
just has to replace its log so it is

628
00:32:31,940 --> 00:32:37,820
gonna get rid of the fives okay alright

629
00:32:37,820 --> 00:32:38,929
the next thing I want to talk about is

630
00:32:38,929 --> 00:32:42,140
persistence you'll notice in Figure two

631
00:32:42,140 --> 00:32:44,510
that the state in the upper left-hand

632
00:32:44,510 --> 00:32:47,750
corners sort of divided and summer

633
00:32:47,750 --> 00:32:50,830
marked persistent and some are marked

634
00:32:50,830 --> 00:32:54,649
volatile and what's going on here is

635
00:32:54,649 --> 00:32:57,649
that the the distinction between

636
00:32:57,649 --> 00:32:59,899
persistence and volatile you know only

637
00:32:59,899 --> 00:33:03,559
matters if a server reboots crashes and

638
00:33:03,559 --> 00:33:06,260
restarts because the persistent what the

639
00:33:06,260 --> 00:33:08,210
persistent means is that if you change

640
00:33:08,210 --> 00:33:09,740
one of those items it's marked

641
00:33:09,740 --> 00:33:14,120
persistent you're supposed to the server

642
00:33:14,120 --> 00:33:15,710
supposed to write it to disk or to some

643
00:33:15,710 --> 00:33:17,929
other non-volatile storage like as

644
00:33:17,929 --> 00:33:20,799
or battery-backed something or whatever

645
00:33:20,799 --> 00:33:23,450
that will ensure that if the server

646
00:33:23,450 --> 00:33:26,330
restarts that it will be able to find

647
00:33:26,330 --> 00:33:28,490
that information and sort of reload it

648
00:33:28,490 --> 00:33:34,159
into memory and that's to allow us to

649
00:33:34,159 --> 00:33:35,990
allow servers to be able to pick up

650
00:33:35,990 --> 00:33:37,940
where they left off if they crash and

651
00:33:37,940 --> 00:33:46,399
restart now you might think that it

652
00:33:46,399 --> 00:33:48,169
would it would be sufficient and simpler

653
00:33:48,169 --> 00:33:51,710
to say well if a server crashes then we

654
00:33:51,710 --> 00:33:55,879
just throw it away and or we need to be

655
00:33:55,879 --> 00:33:57,559
able to throw it away and replace it

656
00:33:57,559 --> 00:33:59,090
with a brand-new empty server and bring

657
00:33:59,090 --> 00:34:01,970
it up to speed right and of course you

658
00:34:01,970 --> 00:34:04,610
do actually it is vital to be able to do

659
00:34:04,610 --> 00:34:06,590
that right because if some server

660
00:34:06,590 --> 00:34:08,179
suffers a failure of some catastrophic

661
00:34:08,179 --> 00:34:10,790
failure like it's you know disk melts or

662
00:34:10,790 --> 00:34:14,480
something you absolutely need to be able

663
00:34:14,480 --> 00:34:17,119
to replace it and you cannot count on

664
00:34:17,119 --> 00:34:18,889
getting anything useful off its disk if

665
00:34:18,889 --> 00:34:20,719
something bad happened to its disk so we

666
00:34:20,719 --> 00:34:22,040
absolutely need to be able to replace

667
00:34:22,040 --> 00:34:24,859
completely replace servers that have no

668
00:34:24,859 --> 00:34:28,369
state whatsoever you might think that's

669
00:34:28,369 --> 00:34:30,379
sufficient to handle any difficulties

670
00:34:30,379 --> 00:34:32,599
but it's actually not it turns out that

671
00:34:32,599 --> 00:34:34,760
another common failure mode is power

672
00:34:34,760 --> 00:34:38,540
failure of you know the entire cluster

673
00:34:38,540 --> 00:34:40,699
where they all stop executing at the

674
00:34:40,699 --> 00:34:43,129
same time right and in that case we

675
00:34:43,129 --> 00:34:46,790
can't handle or we can't handle that

676
00:34:46,790 --> 00:34:48,679
failure by simply throwing away the

677
00:34:48,679 --> 00:34:50,719
servers and replacing them with new

678
00:34:50,719 --> 00:34:53,750
hardware that we buy from Dell we

679
00:34:53,750 --> 00:34:56,480
actually have to be able to get off the

680
00:34:56,480 --> 00:34:58,970
ground we need to be able to get a copy

681
00:34:58,970 --> 00:35:01,640
of the state back in order to keep

682
00:35:01,640 --> 00:35:04,130
executing if we want our service to be

683
00:35:04,130 --> 00:35:07,010
fault tolerant and therefore in order at

684
00:35:07,010 --> 00:35:09,290
least in order to handle the situation

685
00:35:09,290 --> 00:35:11,690
of simultaneous power failure we have to

686
00:35:11,690 --> 00:35:13,400
have a way for the server's to sort of

687
00:35:13,400 --> 00:35:15,319
save their state somewhere where it will

688
00:35:15,319 --> 00:35:19,040
be available when the power returns and

689
00:35:19,040 --> 00:35:20,569
that's one way of viewing what's going

690
00:35:20,569 --> 00:35:23,960
on with persistence it said that's the

691
00:35:23,960 --> 00:35:26,490
state that's required

692
00:35:26,490 --> 00:35:28,859
to get a server going again I'm after

693
00:35:28,859 --> 00:35:31,200
either a single power failure or power

694
00:35:31,200 --> 00:35:33,589
failure of the entire cluster

695
00:35:33,589 --> 00:35:38,609
alright so figure two this three items

696
00:35:38,609 --> 00:35:42,500
only three items are persistent so

697
00:35:44,900 --> 00:35:49,200
there's a log that's like all the log

698
00:35:49,200 --> 00:36:03,779
entries current term and voted for and

699
00:36:03,779 --> 00:36:06,089
by the way you know one of us server

700
00:36:06,089 --> 00:36:07,559
reboots it actually has to make an

701
00:36:07,559 --> 00:36:09,839
explicit check to make sure that these

702
00:36:09,839 --> 00:36:14,849
data are valid on its disk before it

703
00:36:14,849 --> 00:36:17,220
rejoins the raft cluster I have to have

704
00:36:17,220 --> 00:36:18,869
some way of saying oh yeah I actually do

705
00:36:18,869 --> 00:36:20,400
have some save persistent state as

706
00:36:20,400 --> 00:36:24,180
opposed to a bunch of zeros that that

707
00:36:24,180 --> 00:36:28,380
are not valid all right so the reason

708
00:36:28,380 --> 00:36:34,170
why log has to be persisted is that at

709
00:36:34,170 --> 00:36:36,029
least according to figure two this is

710
00:36:36,029 --> 00:36:40,160
the only record of the application state

711
00:36:40,160 --> 00:36:42,119
that is figure two doesn't really have a

712
00:36:42,119 --> 00:36:44,160
notion fears two does not say that we

713
00:36:44,160 --> 00:36:46,260
have to persist the application state so

714
00:36:46,260 --> 00:36:48,329
if we're running a database or you know

715
00:36:48,329 --> 00:36:50,549
a test and set service like for vmware

716
00:36:50,549 --> 00:36:53,309
ft the actual database or the actual

717
00:36:53,309 --> 00:36:55,049
value of the test and set flag isn't

718
00:36:55,049 --> 00:36:57,210
persistent according to figure two only

719
00:36:57,210 --> 00:36:59,250
the logins and so when the server

720
00:36:59,250 --> 00:37:02,160
restarts the only information available

721
00:37:02,160 --> 00:37:05,220
to reconstruct the application state is

722
00:37:05,220 --> 00:37:08,460
the sequence of commands in the log and

723
00:37:08,460 --> 00:37:13,440
so that has to be persisted that's what

724
00:37:13,440 --> 00:37:17,369
about current term why does current term

725
00:37:17,369 --> 00:37:20,329
have to be persistent

726
00:37:34,589 --> 00:37:37,030
yeah so they're both about ensuring that

727
00:37:37,030 --> 00:37:39,760
there's only one that each term has at

728
00:37:39,760 --> 00:37:43,150
most one leader so yeah so voted for the

729
00:37:43,150 --> 00:37:45,910
specific you know potential damaging

730
00:37:45,910 --> 00:37:48,339
case is that if a server receives a boat

731
00:37:48,339 --> 00:37:50,800
request and votes for server one and

732
00:37:50,800 --> 00:37:53,260
then it crashes and if it didn't persist

733
00:37:53,260 --> 00:37:55,720
this the identity of who had voted for

734
00:37:55,720 --> 00:37:58,000
and in my crash we start get another

735
00:37:58,000 --> 00:37:59,920
boat request for the same term from

736
00:37:59,920 --> 00:38:01,839
server two and say gosh I haven't voted

737
00:38:01,839 --> 00:38:03,550
for anybody because my voted for is

738
00:38:03,550 --> 00:38:03,940
blank

739
00:38:03,940 --> 00:38:05,859
now I'm gonna vote for server 2 and now

740
00:38:05,859 --> 00:38:08,349
our servers voted for server 1 and for

741
00:38:08,349 --> 00:38:12,160
server 2 in the same term and that might

742
00:38:12,160 --> 00:38:14,290
allow two servers

743
00:38:14,290 --> 00:38:16,000
since both server and server to voted

744
00:38:16,000 --> 00:38:17,980
for themselves they both may think they

745
00:38:17,980 --> 00:38:19,210
have a majority out of three and they're

746
00:38:19,210 --> 00:38:20,440
both going to become leader now we have

747
00:38:20,440 --> 00:38:23,349
two simultaneous servers for the same

748
00:38:23,349 --> 00:38:24,910
term so this that's why I voted for it

749
00:38:24,910 --> 00:38:28,569
has to be persistent current term is

750
00:38:28,569 --> 00:38:30,700
gonna be a little more subtle but we

751
00:38:30,700 --> 00:38:34,510
actually talked before about how you

752
00:38:34,510 --> 00:38:36,400
know again we don't want to have more

753
00:38:36,400 --> 00:38:38,470
than one server for a term and if we

754
00:38:38,470 --> 00:38:41,220
don't know what term number it is then

755
00:38:41,220 --> 00:38:44,500
we can't necessarily then it may be hard

756
00:38:44,500 --> 00:38:46,780
to ensure that there's only one server

757
00:38:46,780 --> 00:38:49,780
for a term and I think maybe in this

758
00:38:49,780 --> 00:38:54,099
example ya if s if server 1 was down and

759
00:38:54,099 --> 00:38:57,190
server 2 and server 3 we're gonna try to

760
00:38:57,190 --> 00:38:59,680
elect a new server they need evidence

761
00:38:59,680 --> 00:39:02,140
that the correct turn numbers 8 and not

762
00:39:02,140 --> 00:39:04,990
6 right because if they if they forgot

763
00:39:04,990 --> 00:39:06,670
about current term and it was just

764
00:39:06,670 --> 00:39:08,319
server 2 and server 3 voting for each

765
00:39:08,319 --> 00:39:09,550
other and they only had their log to

766
00:39:09,550 --> 00:39:10,990
look at they might think the next term

767
00:39:10,990 --> 00:39:12,849
should be term 6 they did that they

768
00:39:12,849 --> 00:39:14,680
start producing stuff for term 6 but now

769
00:39:14,680 --> 00:39:16,119
there's gonna be a lot of confusion

770
00:39:16,119 --> 00:39:18,720
because we have two different term sixes

771
00:39:18,720 --> 00:39:21,720
and so that's the reason my current term

772
00:39:21,720 --> 00:39:24,819
has to be persistent to preserve

773
00:39:24,819 --> 00:39:27,579
evidence about term numbers that have

774
00:39:27,579 --> 00:39:34,410
already been used these have to be

775
00:39:34,410 --> 00:39:38,440
persisted pretty much every time you

776
00:39:38,440 --> 00:39:42,640
change them right so certainly the safe

777
00:39:42,640 --> 00:39:44,170
thing to do is every time you add an

778
00:39:44,170 --> 00:39:46,900
entry of log or change current term

779
00:39:46,900 --> 00:39:51,190
are said voted for you need you probably

780
00:39:51,190 --> 00:39:53,320
need to persist that and in a real raft

781
00:39:53,320 --> 00:39:54,520
server that would mean writing it to the

782
00:39:54,520 --> 00:39:56,320
disk so you'd have some set of files

783
00:39:56,320 --> 00:39:59,230
that recorded this stuff you can

784
00:39:59,230 --> 00:40:01,990
probably be a little bit you may be can

785
00:40:01,990 --> 00:40:04,619
cut some corners if you observed that

786
00:40:04,619 --> 00:40:08,140
you don't need to persist these things

787
00:40:08,140 --> 00:40:09,730
until you communicate with the outside

788
00:40:09,730 --> 00:40:11,890
world so there may be some opportunity

789
00:40:11,890 --> 00:40:13,210
for a little bit of batching by saying

790
00:40:13,210 --> 00:40:14,500
well we don't have to persist anything

791
00:40:14,500 --> 00:40:17,230
until we're about to reply to an RPC or

792
00:40:17,230 --> 00:40:20,740
about to send out an RPC I mean that may

793
00:40:20,740 --> 00:40:23,220
allow you to avoid a few persisting x'

794
00:40:23,220 --> 00:40:27,060
the reason that's important is that

795
00:40:27,060 --> 00:40:31,180
writing stuff to disk is can be very

796
00:40:31,180 --> 00:40:32,619
expensive it's a if it's a mechanical

797
00:40:32,619 --> 00:40:34,330
hard drive that we're talking about then

798
00:40:34,330 --> 00:40:37,030
writing anything you know if the way

799
00:40:37,030 --> 00:40:38,650
we're persisting is writing files on the

800
00:40:38,650 --> 00:40:41,380
disk writing anything on the disk cost

801
00:40:41,380 --> 00:40:43,030
you about 10 milliseconds because you

802
00:40:43,030 --> 00:40:45,270
either have to wait for the disk to spin

803
00:40:45,270 --> 00:40:47,560
for the point you want to write to spin

804
00:40:47,560 --> 00:40:49,900
under the head which disk only rotates

805
00:40:49,900 --> 00:40:51,849
about once every 10 milliseconds or

806
00:40:51,849 --> 00:40:53,140
worse that you may actually have to seek

807
00:40:53,140 --> 00:40:55,690
to move the arm the right track right so

808
00:40:55,690 --> 00:40:58,570
these per systems can be terribly

809
00:40:58,570 --> 00:41:01,510
terribly expensive and if for sort of

810
00:41:01,510 --> 00:41:03,520
any kind of straightforward design

811
00:41:03,520 --> 00:41:06,220
they're likely to be the limiting factor

812
00:41:06,220 --> 00:41:09,089
in performance because they mean that

813
00:41:09,089 --> 00:41:13,690
doing anything anything whatsoever on

814
00:41:13,690 --> 00:41:15,339
these graph servers takes ten

815
00:41:15,339 --> 00:41:18,580
milliseconds a pop and 10 milliseconds

816
00:41:18,580 --> 00:41:20,410
as far longer than it takes to say send

817
00:41:20,410 --> 00:41:23,320
an RPC or almost anything else you might

818
00:41:23,320 --> 00:41:26,170
do 10 milliseconds each means you can

819
00:41:26,170 --> 00:41:29,609
just never if you persist data to a

820
00:41:29,609 --> 00:41:31,869
mechanical drive you just can never

821
00:41:31,869 --> 00:41:33,400
build a raft service it can serve more

822
00:41:33,400 --> 00:41:37,330
than 100 requests per second because

823
00:41:37,330 --> 00:41:38,530
that's what you get it at 10

824
00:41:38,530 --> 00:41:41,619
milliseconds per operation and you know

825
00:41:41,619 --> 00:41:44,770
this is this cost so this is really all

826
00:41:44,770 --> 00:41:48,420
about cost of synchronous

827
00:41:49,920 --> 00:41:58,090
just updates and it comes up in many

828
00:41:58,090 --> 00:41:59,530
systems like file systems the file

829
00:41:59,530 --> 00:42:00,970
systems that are running in your laptops

830
00:42:00,970 --> 00:42:03,280
are that the designers spend a huge

831
00:42:03,280 --> 00:42:05,170
amount of time sort of trying to

832
00:42:05,170 --> 00:42:07,120
navigate around the performance problems

833
00:42:07,120 --> 00:42:09,040
of synchronous disk up they think of as

834
00:42:09,040 --> 00:42:10,960
disk writes because in order for stuff

835
00:42:10,960 --> 00:42:12,370
to get safe on your disk in order to

836
00:42:12,370 --> 00:42:14,200
update the file system on your laptop's

837
00:42:14,200 --> 00:42:18,430
disk safely there turns out the file

838
00:42:18,430 --> 00:42:20,620
system has to like be careful about how

839
00:42:20,620 --> 00:42:22,840
it writes and needs to sometimes wait

840
00:42:22,840 --> 00:42:25,420
for the disk to finish writing so this

841
00:42:25,420 --> 00:42:27,880
is a like a cross-cutting issue in all

842
00:42:27,880 --> 00:42:29,740
kinds of systems certainly comes up in

843
00:42:29,740 --> 00:42:33,700
draft if you want it to build a system

844
00:42:33,700 --> 00:42:34,900
they could serve more than a hundred

845
00:42:34,900 --> 00:42:38,830
quests per second then there's a bunch

846
00:42:38,830 --> 00:42:39,940
of options one is you can use a

847
00:42:39,940 --> 00:42:41,770
solid-state drive or some kind of flash

848
00:42:41,770 --> 00:42:44,320
or something solid eight drives can do a

849
00:42:44,320 --> 00:42:50,530
write to the flash memory in maybe a

850
00:42:50,530 --> 00:42:52,600
tenth of a millisecond so that's a

851
00:42:52,600 --> 00:42:55,480
factor of a hundred for you or if you're

852
00:42:55,480 --> 00:42:57,730
even more sophisticated maybe you can

853
00:42:57,730 --> 00:43:02,200
build yourself battery backed DRAM and

854
00:43:02,200 --> 00:43:03,820
do the persistence into battery back

855
00:43:03,820 --> 00:43:07,270
DRAM and then if the server reboots hope

856
00:43:07,270 --> 00:43:11,020
that reboot was took shorter than the

857
00:43:11,020 --> 00:43:12,430
amount of time the battery lasts and

858
00:43:12,430 --> 00:43:14,560
that this stuff you persisted is still

859
00:43:14,560 --> 00:43:17,770
in the RAM and the reason I mean if you

860
00:43:17,770 --> 00:43:19,420
have money and sophistication the reason

861
00:43:19,420 --> 00:43:21,400
to favor that is you can write DRAM you

862
00:43:21,400 --> 00:43:23,230
know millions of times per second and so

863
00:43:23,230 --> 00:43:24,600
it's probably not going to be a

864
00:43:24,600 --> 00:43:28,600
performance bottleneck anyway so that

865
00:43:28,600 --> 00:43:33,370
this problem is why and it's sort of

866
00:43:33,370 --> 00:43:35,230
marking a persistent versus volatile and

867
00:43:35,230 --> 00:43:36,880
figure 2 is like has a lot of

868
00:43:36,880 --> 00:43:38,910
significance for performance as well as

869
00:43:38,910 --> 00:43:43,690
crash recovery and correctness any

870
00:43:43,690 --> 00:43:48,300
questions about persisting yeah

871
00:43:55,570 --> 00:44:08,240
yes alright so your question is

872
00:44:08,240 --> 00:44:10,340
basically you're writing code say go

873
00:44:10,340 --> 00:44:12,410
code for your raft implementation or

874
00:44:12,410 --> 00:44:13,520
you're trying to write a real rafterman

875
00:44:13,520 --> 00:44:15,200
implementation and you actually want to

876
00:44:15,200 --> 00:44:18,500
make sure that when you persist your an

877
00:44:18,500 --> 00:44:20,180
update to the law or the current term or

878
00:44:20,180 --> 00:44:21,800
whatever that it in fact will be there

879
00:44:21,800 --> 00:44:23,870
after a crash and reboot like what's the

880
00:44:23,870 --> 00:44:26,300
recipe for what you have to do to make

881
00:44:26,300 --> 00:44:28,010
sure it's there and your observation

882
00:44:28,010 --> 00:44:31,040
that if you call you know on a UNIX or

883
00:44:31,040 --> 00:44:34,450
Linux or whatever Mac if you call right

884
00:44:34,450 --> 00:44:36,980
you know the right system call is how

885
00:44:36,980 --> 00:44:38,510
you write to a disk file you simply call

886
00:44:38,510 --> 00:44:41,330
right as you pointed out it is not the

887
00:44:41,330 --> 00:44:43,670
case that after the write returns the

888
00:44:43,670 --> 00:44:45,800
data is safe on disk and will survive a

889
00:44:45,800 --> 00:44:48,650
reboot it almost certainly isn't almost

890
00:44:48,650 --> 00:44:51,200
certainly not on disk so the you know

891
00:44:51,200 --> 00:44:53,480
the particular piece of magic you need

892
00:44:53,480 --> 00:44:56,210
to do is on unix at any rate you need

893
00:44:56,210 --> 00:44:58,510
you need to call right so you cannot

894
00:44:58,510 --> 00:45:01,340
write some file you've opened that's

895
00:45:01,340 --> 00:45:02,720
going to contain the stuff that you want

896
00:45:02,720 --> 00:45:06,290
to write and then you got a call this F

897
00:45:06,290 --> 00:45:09,710
st. call which on most systems the

898
00:45:09,710 --> 00:45:12,010
guarantee is that F sync doesn't return

899
00:45:12,010 --> 00:45:15,350
until all the data you've previously

900
00:45:15,350 --> 00:45:18,140
written into this file is safely on the

901
00:45:18,140 --> 00:45:22,130
surface on the media in a place on a

902
00:45:22,130 --> 00:45:23,780
place where it will still be there if

903
00:45:23,780 --> 00:45:26,930
there's a crash so so this thing is some

904
00:45:26,930 --> 00:45:29,030
then this call is an expensive call and

905
00:45:29,030 --> 00:45:30,620
that's why it's a separate that's why

906
00:45:30,620 --> 00:45:33,500
Wright doesn't write the disk only F

907
00:45:33,500 --> 00:45:35,420
sync does is because it's so expensive

908
00:45:35,420 --> 00:45:37,010
you would never want to do it unless you

909
00:45:37,010 --> 00:45:40,460
really wanted to persist some stuff some

910
00:45:40,460 --> 00:45:46,280
data okay so you can use more expensive

911
00:45:46,280 --> 00:45:47,930
disk hardware the other trick people

912
00:45:47,930 --> 00:45:51,410
play a lot is to try to batch that is if

913
00:45:51,410 --> 00:45:53,810
you can if client requests are if you

914
00:45:53,810 --> 00:45:55,370
have a lot of client requests coming in

915
00:45:55,370 --> 00:45:57,410
maybe you should accept a lot of them

916
00:45:57,410 --> 00:45:59,210
and not reply to any of them for a

917
00:45:59,210 --> 00:46:00,860
little bit we call a lot of them

918
00:46:00,860 --> 00:46:01,640
accumulate

919
00:46:01,640 --> 00:46:05,000
and then persist you know a hundred log

920
00:46:05,000 --> 00:46:07,610
entries at a time from your hundred

921
00:46:07,610 --> 00:46:09,800
clients and you know only then send out

922
00:46:09,800 --> 00:46:12,320
the append entries good because you do

923
00:46:12,320 --> 00:46:13,550
actually have to persist this stuff to

924
00:46:13,550 --> 00:46:16,130
disk if you receive a client request you

925
00:46:16,130 --> 00:46:17,600
have to persist the new entry to disk

926
00:46:17,600 --> 00:46:20,330
before you send the append entries our

927
00:46:20,330 --> 00:46:24,920
PCs the followers because you're not

928
00:46:24,920 --> 00:46:26,690
allowed if the leader you know the

929
00:46:26,690 --> 00:46:29,420
leader it's essentially promising to

930
00:46:29,420 --> 00:46:34,400
commit that that request and can't

931
00:46:34,400 --> 00:46:35,150
forget about it

932
00:46:35,150 --> 00:46:37,490
and indeed the followers have to persist

933
00:46:37,490 --> 00:46:39,260
the new log entry to their disk before

934
00:46:39,260 --> 00:46:40,880
they reply to the append entries because

935
00:46:40,880 --> 00:46:42,170
they were apply to the append entries

936
00:46:42,170 --> 00:46:45,110
it's also a promise to preserve and

937
00:46:45,110 --> 00:46:46,970
eventually commit that log entry so they

938
00:46:46,970 --> 00:46:48,620
can't be allowed to forget about it if

939
00:46:48,620 --> 00:46:51,950
they crash other questions about

940
00:46:51,950 --> 00:47:01,430
persistence all right well final you

941
00:47:01,430 --> 00:47:02,780
know a little detail about persistence

942
00:47:02,780 --> 00:47:09,620
is that some of the stuff in figure two

943
00:47:09,620 --> 00:47:11,300
is not persistent and so it's worth

944
00:47:11,300 --> 00:47:12,770
scratching your head a little bit about

945
00:47:12,770 --> 00:47:15,290
why commit index lasts apply next index

946
00:47:15,290 --> 00:47:17,240
and match index why it's fair game for

947
00:47:17,240 --> 00:47:19,640
them to be simply thrown away if the

948
00:47:19,640 --> 00:47:22,010
server crashes and restarts like why

949
00:47:22,010 --> 00:47:24,860
wasn't you know commit index or last

950
00:47:24,860 --> 00:47:26,510
apply it like geez last applied is the

951
00:47:26,510 --> 00:47:29,360
record of how much we've executed right

952
00:47:29,360 --> 00:47:30,440
if we throw that away aren't we gonna

953
00:47:30,440 --> 00:47:32,180
execute log entries twice and is that

954
00:47:32,180 --> 00:47:35,690
correct how about that why is why is it

955
00:47:35,690 --> 00:47:39,310
safe to throw away last applied

956
00:47:46,680 --> 00:47:55,630
yes I am we're all about simplicity and

957
00:47:55,630 --> 00:47:58,150
safety here with raft so that's exactly

958
00:47:58,150 --> 00:48:02,320
correct the the reason why all that

959
00:48:02,320 --> 00:48:04,240
other stuff can be non-volatile as you

960
00:48:04,240 --> 00:48:06,880
mentioned I mean sorry volatile the

961
00:48:06,880 --> 00:48:07,930
reason why those other fields can be

962
00:48:07,930 --> 00:48:10,360
volatile and thrown away is that we can

963
00:48:10,360 --> 00:48:12,580
the leader can reconstruct sort of

964
00:48:12,580 --> 00:48:15,340
what's been committed by inspecting its

965
00:48:15,340 --> 00:48:17,650
own log and by the results of append

966
00:48:17,650 --> 00:48:19,090
entries that it sends out to the

967
00:48:19,090 --> 00:48:20,680
followers I mean initially the leader if

968
00:48:20,680 --> 00:48:22,300
it if everybody restarts because they

969
00:48:22,300 --> 00:48:23,320
experienced a power failure

970
00:48:23,320 --> 00:48:24,940
initially the leader does not know

971
00:48:24,940 --> 00:48:27,880
what's committed what's executed but

972
00:48:27,880 --> 00:48:29,680
when it sends out log and append entries

973
00:48:29,680 --> 00:48:31,210
it'll sort of gather back information

974
00:48:31,210 --> 00:48:32,770
and essentially from the followers about

975
00:48:32,770 --> 00:48:34,780
What's in how much of their logs match

976
00:48:34,780 --> 00:48:36,370
the leaders and therefore how much must

977
00:48:36,370 --> 00:48:38,070
have been committed before the crash

978
00:48:38,070 --> 00:48:41,950
another thing in the 4-2 world which is

979
00:48:41,950 --> 00:48:43,150
not the real world

980
00:48:43,150 --> 00:48:45,130
another thing about figure two is that

981
00:48:45,130 --> 00:48:47,770
figure two assumes that the application

982
00:48:47,770 --> 00:48:51,580
state is destroyed and thrown away if

983
00:48:51,580 --> 00:48:54,310
there's a crash in a restart so the

984
00:48:54,310 --> 00:48:55,900
figure two world assumes that while log

985
00:48:55,900 --> 00:48:57,550
is persistent that the application state

986
00:48:57,550 --> 00:49:00,100
is absolutely not persistent required

987
00:49:00,100 --> 00:49:04,200
not to be consistent in figure 2 because

988
00:49:04,200 --> 00:49:07,390
the in figure 2 the log is preserved

989
00:49:07,390 --> 00:49:10,030
persisted from the very beginning of the

990
00:49:10,030 --> 00:49:13,000
system and so what's going to happen if

991
00:49:13,000 --> 00:49:15,640
you sort of play out what the various

992
00:49:15,640 --> 00:49:18,460
rules in figure 2 after a leader restart

993
00:49:18,460 --> 00:49:21,130
is that the leader will eventually re

994
00:49:21,130 --> 00:49:24,010
execute every single log entry that is

995
00:49:24,010 --> 00:49:26,500
handed to the application you know

996
00:49:26,500 --> 00:49:28,600
starting with log entry one after a

997
00:49:28,600 --> 00:49:31,420
reboot it's the raft is gonna hand the

998
00:49:31,420 --> 00:49:33,340
application every log entry starting

999
00:49:33,340 --> 00:49:34,840
from one and so that will after a

1000
00:49:34,840 --> 00:49:36,790
restart the application will completely

1001
00:49:36,790 --> 00:49:39,640
reconstruct its state from scratch by a

1002
00:49:39,640 --> 00:49:41,890
replay from the beginning of the time of

1003
00:49:41,890 --> 00:49:45,430
the entire log after each restart and

1004
00:49:45,430 --> 00:49:46,360
again that's like a sort of

1005
00:49:46,360 --> 00:49:49,390
straightforward elegant plan but

1006
00:49:49,390 --> 00:49:55,290
obviously potentially very slow

1007
00:49:56,119 --> 00:49:58,040
which brings us to the next topic which

1008
00:49:58,040 --> 00:50:04,670
is log compaction and and snapshots and

1009
00:50:04,670 --> 00:50:07,970
this has a lot to do with lab 3b

1010
00:50:07,970 --> 00:50:09,619
actually you'll see log compaction and

1011
00:50:09,619 --> 00:50:13,970
snapshots in vlog 3b in lab 3b and so

1012
00:50:13,970 --> 00:50:15,440
the problem that log compaction and

1013
00:50:15,440 --> 00:50:18,800
snapshotting is solving a raft is that

1014
00:50:18,800 --> 00:50:20,690
indeed for a long-running system that's

1015
00:50:20,690 --> 00:50:22,359
been going for weeks or months or years

1016
00:50:22,359 --> 00:50:25,310
if we just follow the figure 2 rules the

1017
00:50:25,310 --> 00:50:27,410
log just keeps on growing may end up you

1018
00:50:27,410 --> 00:50:28,490
know millions and millions of entries

1019
00:50:28,490 --> 00:50:30,770
long and so requires a lot of memory to

1020
00:50:30,770 --> 00:50:34,130
store if you store it on disk like if

1021
00:50:34,130 --> 00:50:35,359
you have to persist it every time you

1022
00:50:35,359 --> 00:50:37,130
persist the log it's using up a huge I

1023
00:50:37,130 --> 00:50:39,200
may not space on disk and if a server

1024
00:50:39,200 --> 00:50:41,990
ever be starts it has to reconstruct its

1025
00:50:41,990 --> 00:50:44,660
state by replaying these millions and

1026
00:50:44,660 --> 00:50:46,040
millions of log entries from the very

1027
00:50:46,040 --> 00:50:47,660
beginning which could take like hours

1028
00:50:47,660 --> 00:50:50,030
for a server to run through its entire

1029
00:50:50,030 --> 00:50:52,790
log and we execute it if it crashes and

1030
00:50:52,790 --> 00:50:54,680
restarts all of which is like similar

1031
00:50:54,680 --> 00:50:56,480
what kind of wasted because before it

1032
00:50:56,480 --> 00:50:58,670
crashed it had already had applications

1033
00:50:58,670 --> 00:51:08,230
state and so in order to cope with this

1034
00:51:08,230 --> 00:51:11,750
wrath has this idea of snapshots and the

1035
00:51:11,750 --> 00:51:15,230
sort of idea behind snapshots is to be

1036
00:51:15,230 --> 00:51:18,410
able to save or ask the application to

1037
00:51:18,410 --> 00:51:20,839
save a copy of its state as of a

1038
00:51:20,839 --> 00:51:23,270
particular log entry so we've been

1039
00:51:23,270 --> 00:51:24,920
mostly kind of ignoring the application

1040
00:51:24,920 --> 00:51:28,160
but the fact is that you know if we have

1041
00:51:28,160 --> 00:51:30,140
a suppose we're building a key value

1042
00:51:30,140 --> 00:51:33,349
store under BRAF you know the log is

1043
00:51:33,349 --> 00:51:34,940
gonna contain a bunch of you know

1044
00:51:34,940 --> 00:51:37,099
putting gets or read and write request

1045
00:51:37,099 --> 00:51:39,680
so maybe a law contains you know a put

1046
00:51:39,680 --> 00:51:42,410
that some client wants to set X to one

1047
00:51:42,410 --> 00:51:44,359
and then another one where it says X to

1048
00:51:44,359 --> 00:51:47,690
2 and then you know y equals 7 or

1049
00:51:47,690 --> 00:51:51,050
whatever and if there's no crashes as

1050
00:51:51,050 --> 00:51:53,569
the raft is executing along there's

1051
00:51:53,569 --> 00:51:55,730
going to be this if the layer above Rath

1052
00:51:55,730 --> 00:51:57,260
there's going to be this application and

1053
00:51:57,260 --> 00:51:59,390
the application if it's a key value

1054
00:51:59,390 --> 00:52:01,520
store databases it's going to be meeting

1055
00:52:01,520 --> 00:52:05,420
this table and as raft hands it one

1056
00:52:05,420 --> 00:52:07,220
command after our next

1057
00:52:07,220 --> 00:52:09,140
the applications going to update its

1058
00:52:09,140 --> 00:52:10,880
table so you know after the first

1059
00:52:10,880 --> 00:52:12,890
command it's going to set X to one and

1060
00:52:12,890 --> 00:52:14,300
it's stable after the second command

1061
00:52:14,300 --> 00:52:18,400
it's going to update its table you know

1062
00:52:19,630 --> 00:52:22,040
one interesting fact is that for most

1063
00:52:22,040 --> 00:52:24,320
applications the application state is

1064
00:52:24,320 --> 00:52:26,990
likely to be much smaller than the

1065
00:52:26,990 --> 00:52:29,840
corresponding log right at some level we

1066
00:52:29,840 --> 00:52:31,550
know that the the you know the log and

1067
00:52:31,550 --> 00:52:33,710
the state are the log in that and the

1068
00:52:33,710 --> 00:52:35,150
state as of some point in the log are

1069
00:52:35,150 --> 00:52:38,320
kind of interchangeable right they both

1070
00:52:38,320 --> 00:52:40,820
sort of implied the same thing about the

1071
00:52:40,820 --> 00:52:44,570
state of the application but the log may

1072
00:52:44,570 --> 00:52:46,100
contain a lot of you know a lot of

1073
00:52:46,100 --> 00:52:48,170
multiple assignments 2x they use up a

1074
00:52:48,170 --> 00:52:49,850
lot of space in the log but are also to

1075
00:52:49,850 --> 00:52:51,860
effectively compact it down to a single

1076
00:52:51,860 --> 00:52:53,510
entry in the table and that's pretty

1077
00:52:53,510 --> 00:52:56,300
typical of these replicated applications

1078
00:52:56,300 --> 00:53:00,110
but the point is that instead of storing

1079
00:53:00,110 --> 00:53:02,690
the log which may go to be huge we have

1080
00:53:02,690 --> 00:53:05,330
the option of storing instead the table

1081
00:53:05,330 --> 00:53:08,060
which might be a lot smaller and that's

1082
00:53:08,060 --> 00:53:11,630
what the snapshots are doing so when

1083
00:53:11,630 --> 00:53:14,420
raft feels that it's log has gotten to

1084
00:53:14,420 --> 00:53:17,690
be too large you know more than a

1085
00:53:17,690 --> 00:53:19,190
megabyte or ten megabytes or whatever

1086
00:53:19,190 --> 00:53:21,620
some arbitrary limit raft will ask the

1087
00:53:21,620 --> 00:53:24,260
application to take make a snapshot of

1088
00:53:24,260 --> 00:53:26,990
it the application state as of a certain

1089
00:53:26,990 --> 00:53:28,370
point in the log

1090
00:53:28,370 --> 00:53:30,760
so if we add if raft asked the

1091
00:53:30,760 --> 00:53:33,110
application for a snapshot reference it

1092
00:53:33,110 --> 00:53:35,300
would pick a point in the log that the

1093
00:53:35,300 --> 00:53:37,370
snapshot referred to and require the

1094
00:53:37,370 --> 00:53:39,770
application to produce a snapshot as at

1095
00:53:39,770 --> 00:53:41,570
that point this is extremely critical

1096
00:53:41,570 --> 00:53:44,480
because the because what we're about to

1097
00:53:44,480 --> 00:53:45,980
do is throw away everything before that

1098
00:53:45,980 --> 00:53:47,360
point so if there's not a will to find

1099
00:53:47,360 --> 00:53:48,860
point that corresponds to a snapshot

1100
00:53:48,860 --> 00:53:51,290
then we can't safely throw away the log

1101
00:53:51,290 --> 00:53:54,910
before that point so that means that

1102
00:53:54,910 --> 00:53:57,020
Rath is gonna have you know ask for

1103
00:53:57,020 --> 00:53:58,340
snaps on the snap so it's basically just

1104
00:53:58,340 --> 00:54:00,650
the table it's just about a database

1105
00:54:00,650 --> 00:54:04,520
server and we also need to annotate the

1106
00:54:04,520 --> 00:54:07,400
snapshot with the entry number that are

1107
00:54:07,400 --> 00:54:09,890
corresponds to you so it's basically you

1108
00:54:09,890 --> 00:54:12,380
know if the entries are 1 2 3 this

1109
00:54:12,380 --> 00:54:16,400
snapshot corresponds to just after log

1110
00:54:16,400 --> 00:54:19,809
index 3 with the snapshot in hand

1111
00:54:19,809 --> 00:54:23,329
if we persist it to disk rats persistent

1112
00:54:23,329 --> 00:54:26,869
to disk raft never again will need this

1113
00:54:26,869 --> 00:54:33,890
part of the logs and it can simply throw

1114
00:54:33,890 --> 00:54:36,650
it away as long as it persists a

1115
00:54:36,650 --> 00:54:39,589
snapshot as of a certain in debt log

1116
00:54:39,589 --> 00:54:42,710
index plus the log after that index as

1117
00:54:42,710 --> 00:54:44,450
long as that's persisted to disk we

1118
00:54:44,450 --> 00:54:46,480
never going to need to log before that

1119
00:54:46,480 --> 00:54:49,789
and so this is what RAF does the rocks

1120
00:54:49,789 --> 00:54:51,529
ask the application for snapshot gets

1121
00:54:51,529 --> 00:54:52,970
the snapshot saves it to disk with the

1122
00:54:52,970 --> 00:54:54,470
log after that it just throws away this

1123
00:54:54,470 --> 00:54:58,369
log here right and so it really operates

1124
00:54:58,369 --> 00:55:00,950
or the sort of persistence story is all

1125
00:55:00,950 --> 00:55:03,529
about pairs of a snapshot in the log

1126
00:55:03,529 --> 00:55:06,230
after that after the point in the log

1127
00:55:06,230 --> 00:55:09,890
associated with snapshot I don't see

1128
00:55:09,890 --> 00:55:12,700
this yes

1129
00:55:24,309 --> 00:55:27,680
no it's still it's it's you know there's

1130
00:55:27,680 --> 00:55:29,270
these sort of phantom entries one two

1131
00:55:29,270 --> 00:55:31,430
three and this you know suffix of the

1132
00:55:31,430 --> 00:55:37,390
log is indeed viewed as still the it's

1133
00:55:37,390 --> 00:55:39,230
maybe the right way to think of it is

1134
00:55:39,230 --> 00:55:41,240
still there's just one log except these

1135
00:55:41,240 --> 00:55:43,510
entries are sort of phantom entries that

1136
00:55:43,510 --> 00:55:46,579
we that we can view as being kind of

1137
00:55:46,579 --> 00:55:48,770
there in principle but since we're we

1138
00:55:48,770 --> 00:55:51,020
never need to look at them because we

1139
00:55:51,020 --> 00:55:52,549
have the snapshot the fact that they

1140
00:55:52,549 --> 00:55:53,869
just happened not to be stored anywhere

1141
00:55:53,869 --> 00:55:57,829
is neither here nor there but it's but

1142
00:55:57,829 --> 00:55:58,700
yeah you should think of it as being

1143
00:55:58,700 --> 00:56:01,640
stole the same log it's just not just

1144
00:56:01,640 --> 00:56:04,819
threw away their early entries did this

1145
00:56:04,819 --> 00:56:06,440
that's a maybe a little bit too glib of

1146
00:56:06,440 --> 00:56:07,579
an answer because the fact is that

1147
00:56:07,579 --> 00:56:10,130
figure two talks about the log in ways

1148
00:56:10,130 --> 00:56:12,559
that makes it that if you just follow

1149
00:56:12,559 --> 00:56:14,240
figure to you sometimes still need these

1150
00:56:14,240 --> 00:56:15,799
earlier entries and so you'll have to

1151
00:56:15,799 --> 00:56:17,420
reinterpret figure two a little bit in

1152
00:56:17,420 --> 00:56:19,670
light of the fact that sometimes it says

1153
00:56:19,670 --> 00:56:22,309
blah blah blah a log entry where the log

1154
00:56:22,309 --> 00:56:32,680
entry doesn't exist okay

1155
00:56:39,390 --> 00:56:43,119
okay and so what happens on a restart

1156
00:56:43,119 --> 00:56:44,890
so the restart story is a little more

1157
00:56:44,890 --> 00:56:46,329
complicated in it than it used to be

1158
00:56:46,329 --> 00:56:48,700
with just a log what happens on a

1159
00:56:48,700 --> 00:56:50,289
restart is that there needs to be away

1160
00:56:50,289 --> 00:56:54,549
for raft to give the latest for graph to

1161
00:56:54,549 --> 00:56:56,980
find the latest snapshot log pair on its

1162
00:56:56,980 --> 00:57:01,059
disk and hand the snapshot to the

1163
00:57:01,059 --> 00:57:03,130
application because we no longer are

1164
00:57:03,130 --> 00:57:04,990
able to replay you know all the log

1165
00:57:04,990 --> 00:57:06,460
entries so there must be some other way

1166
00:57:06,460 --> 00:57:08,740
to initialize the application basically

1167
00:57:08,740 --> 00:57:10,240
not only is the application have to be

1168
00:57:10,240 --> 00:57:11,440
able to produce a snapshot of

1169
00:57:11,440 --> 00:57:13,930
application state but but it has to be

1170
00:57:13,930 --> 00:57:15,839
able to absorb a previously made

1171
00:57:15,839 --> 00:57:17,980
snapshot and sort of reconstruct it

1172
00:57:17,980 --> 00:57:20,740
stable in memory from a snapshot and so

1173
00:57:20,740 --> 00:57:22,240
this now even though raft is kind of

1174
00:57:22,240 --> 00:57:23,710
managing this whole snapshotting stuff

1175
00:57:23,710 --> 00:57:26,200
the snapshot contents are really the

1176
00:57:26,200 --> 00:57:28,299
property to the application and RAF

1177
00:57:28,299 --> 00:57:29,950
doesn't even understand what's in here

1178
00:57:29,950 --> 00:57:31,420
only the application does because it's

1179
00:57:31,420 --> 00:57:33,010
all full of application specific

1180
00:57:33,010 --> 00:57:36,279
information so after a restart the

1181
00:57:36,279 --> 00:57:39,789
application has to be able to absorb the

1182
00:57:39,789 --> 00:57:45,789
latest snapshot that raft found so for

1183
00:57:45,789 --> 00:57:48,750
just this simple it would be simple

1184
00:57:48,750 --> 00:57:52,089
unfortunately this snapshotting and in

1185
00:57:52,089 --> 00:57:54,579
particular the idea that the leader

1186
00:57:54,579 --> 00:57:56,920
might throw away part of its log

1187
00:57:56,920 --> 00:57:59,680
introduces a major piece of complexity

1188
00:57:59,680 --> 00:58:01,809
and that is that if there's some

1189
00:58:01,809 --> 00:58:05,940
follower out there whose log ends before

1190
00:58:05,940 --> 00:58:10,809
the point at which the leaders log

1191
00:58:10,809 --> 00:58:14,140
starts then unless we invent something

1192
00:58:14,140 --> 00:58:15,819
new we need monney install snapshot

1193
00:58:15,819 --> 00:58:17,920
unless we invent something new that

1194
00:58:17,920 --> 00:58:20,859
follower can never get up-to-date right

1195
00:58:20,859 --> 00:58:23,020
because if the followers you know if

1196
00:58:23,020 --> 00:58:25,210
there's some follower whose log only is

1197
00:58:25,210 --> 00:58:27,400
the first two log entries we no longer

1198
00:58:27,400 --> 00:58:29,890
have the log entry three that's required

1199
00:58:29,890 --> 00:58:32,710
to send it to that follower in an append

1200
00:58:32,710 --> 00:58:35,410
entries RPC to allow its log to catch up

1201
00:58:35,410 --> 00:58:41,150
to the leaders now

1202
00:58:41,150 --> 00:58:44,819
we could avoid this problem by having

1203
00:58:44,819 --> 00:58:47,880
the leader never drop part of its log if

1204
00:58:47,880 --> 00:58:50,430
there's any follower out there that

1205
00:58:50,430 --> 00:58:53,369
hasn't caught up to the point at which

1206
00:58:53,369 --> 00:58:54,960
the leader is thinking about doing a

1207
00:58:54,960 --> 00:58:56,490
snapshot because the leader knows

1208
00:58:56,490 --> 00:58:58,920
through next index

1209
00:58:58,920 --> 00:59:00,960
well actually leader doesn't really know

1210
00:59:00,960 --> 00:59:02,569
but the leader could know in principle

1211
00:59:02,569 --> 00:59:05,549
how far each follower had gotten and the

1212
00:59:05,549 --> 00:59:06,660
leader could say well I'm just never

1213
00:59:06,660 --> 00:59:09,299
gonna drop the part of my log before the

1214
00:59:09,299 --> 00:59:12,059
end of the follower with the shortest

1215
00:59:12,059 --> 00:59:16,890
log and that would be okay they might

1216
00:59:16,890 --> 00:59:20,039
actually just be a good idea period the

1217
00:59:20,039 --> 00:59:21,299
reason why that's maybe not such a great

1218
00:59:21,299 --> 00:59:23,039
idea is that of course if a follower

1219
00:59:23,039 --> 00:59:26,730
shut down for a week you know it's not

1220
00:59:26,730 --> 00:59:28,770
gonna be acknowledging log entries and

1221
00:59:28,770 --> 00:59:31,260
that means that the leader can't reduce

1222
00:59:31,260 --> 00:59:34,349
its memory use by snapshotting so the

1223
00:59:34,349 --> 00:59:36,000
way the raft designs chosen to go is

1224
00:59:36,000 --> 00:59:40,289
that the leader is allowed to throw away

1225
00:59:40,289 --> 00:59:42,059
parts of its logs that would be needed

1226
00:59:42,059 --> 00:59:43,619
by some follower and so we need some

1227
00:59:43,619 --> 00:59:45,770
other scheme that append entries to deal

1228
00:59:45,770 --> 00:59:48,029
with the gap between the end of some

1229
00:59:48,029 --> 00:59:49,349
followers log in the beginning of the

1230
00:59:49,349 --> 00:59:51,839
leaders log and so that solution is the

1231
00:59:51,839 --> 01:00:02,880
install snapshot RPC and the deal is

1232
01:00:02,880 --> 01:00:06,930
that when a leader we have some follower

1233
01:00:06,930 --> 01:00:09,480
whose log is that you know just powered

1234
01:00:09,480 --> 01:00:12,240
on its log as short the leaders gonna

1235
01:00:12,240 --> 01:00:14,549
send it and append entries and you know

1236
01:00:14,549 --> 01:00:15,869
it's gonna be forced the leaders gonna

1237
01:00:15,869 --> 01:00:17,250
be forced to backup and at some point

1238
01:00:17,250 --> 01:00:19,079
the leader you know failure or fail

1239
01:00:19,079 --> 01:00:20,819
dependent recalls will cause the leader

1240
01:00:20,819 --> 01:00:23,339
to realize it it's reached the beginning

1241
01:00:23,339 --> 01:00:25,140
of the actual log its doors and at that

1242
01:00:25,140 --> 01:00:27,150
point instead of sending in append

1243
01:00:27,150 --> 01:00:30,329
entries the leader will send its current

1244
01:00:30,329 --> 01:00:33,569
snapshot plus current law well send its

1245
01:00:33,569 --> 01:00:35,670
current snapshot to the follower and

1246
01:00:35,670 --> 01:00:37,890
then presumably immediately follow it

1247
01:00:37,890 --> 01:00:40,079
with an append entries that has the

1248
01:00:40,079 --> 01:00:43,190
leaders current law

1249
01:00:46,770 --> 01:00:49,770
questions

1250
01:00:52,369 --> 01:00:55,249
yeah I'm the sad truth this is like this

1251
01:00:55,249 --> 01:00:59,140
is adds significant complexity here

1252
01:00:59,140 --> 01:01:02,539
Jarrell I'm three partially because of

1253
01:01:02,539 --> 01:01:05,029
the kind of cooperation that's required

1254
01:01:05,029 --> 01:01:07,219
between raff this is sort of a little

1255
01:01:07,219 --> 01:01:08,779
bit of a violation of modularity it

1256
01:01:08,779 --> 01:01:12,049
requires a good deal cooperation like

1257
01:01:12,049 --> 01:01:13,579
for example when an install snapshot

1258
01:01:13,579 --> 01:01:15,979
comes in it's delivered to raft but raft

1259
01:01:15,979 --> 01:01:17,779
really requires the application to

1260
01:01:17,779 --> 01:01:23,239
absorb the snapshot so they have to talk

1261
01:01:23,239 --> 01:01:24,109
to each other more than they otherwise

1262
01:01:24,109 --> 01:01:33,619
might yes the question is that this is

1263
01:01:33,619 --> 01:01:35,210
the way the snapshot is created

1264
01:01:35,210 --> 01:01:36,890
dependent on the application

1265
01:01:36,890 --> 01:01:38,719
it's absolutely it so the snapshot

1266
01:01:38,719 --> 01:01:40,969
creation function is part of the

1267
01:01:40,969 --> 01:01:42,680
application as part of like the key

1268
01:01:42,680 --> 01:01:45,259
value server so raffle you know somehow

1269
01:01:45,259 --> 01:01:46,789
call up to the application and say geez

1270
01:01:46,789 --> 01:01:48,140
you know I really like a snapshot right

1271
01:01:48,140 --> 01:01:50,329
now in the application because only the

1272
01:01:50,329 --> 01:01:53,890
application understands what it's status

1273
01:01:53,890 --> 01:01:57,650
and you know the inverse function by

1274
01:01:57,650 --> 01:01:59,450
which an application reconstructs a

1275
01:01:59,450 --> 01:02:01,729
state from a snapshot files also totally

1276
01:02:01,729 --> 01:02:05,059
application dependent where there's

1277
01:02:05,059 --> 01:02:06,859
intertwining because of course every

1278
01:02:06,859 --> 01:02:09,499
snapshot has to be labeled with a point

1279
01:02:09,499 --> 01:02:12,789
in a log that it corresponds to

1280
01:02:25,270 --> 01:02:27,230
talking about rule six and figure

1281
01:02:27,230 --> 01:02:39,680
thirteen okay so yeah the question here

1282
01:02:39,680 --> 01:02:42,560
is that and you will be faced with this

1283
01:02:42,560 --> 01:02:46,250
in lab three that because the RPC system

1284
01:02:46,250 --> 01:02:48,650
isn't perfectly reliable and perfectly

1285
01:02:48,650 --> 01:02:50,900
sequenced and RBC's can arrive out of

1286
01:02:50,900 --> 01:02:52,640
order or not at all or you may send an

1287
01:02:52,640 --> 01:02:54,650
RPC and get no response and think it was

1288
01:02:54,650 --> 01:02:56,450
lost but actually was delivered and was

1289
01:02:56,450 --> 01:02:58,310
the reply that was lost all these things

1290
01:02:58,310 --> 01:03:02,540
happen including to send to whatever

1291
01:03:02,540 --> 01:03:04,610
install snapshot our pcs and the leaders

1292
01:03:04,610 --> 01:03:06,860
almost certainly sending out many our

1293
01:03:06,860 --> 01:03:08,750
pcs concurrently you know both append

1294
01:03:08,750 --> 01:03:12,200
entries and install snapshots that means

1295
01:03:12,200 --> 01:03:15,020
that you can get things like install

1296
01:03:15,020 --> 01:03:19,510
snapshot our pcs from deep in the past

1297
01:03:20,560 --> 01:03:25,040
almost anything else right and therefore

1298
01:03:25,040 --> 01:03:29,990
the the follower has to be careful you

1299
01:03:29,990 --> 01:03:31,220
know has to think carefully about an

1300
01:03:31,220 --> 01:03:35,650
install snapshot that arrives and the

1301
01:03:37,270 --> 01:03:39,440
yeah I think the specific thing you're

1302
01:03:39,440 --> 01:03:41,990
asking is that if follower receives that

1303
01:03:41,990 --> 01:03:43,790
an install snapshot that appears to be

1304
01:03:43,790 --> 01:03:46,310
completely redundant that is the install

1305
01:03:46,310 --> 01:03:47,780
snapshot contains information that's

1306
01:03:47,780 --> 01:03:50,390
older than the information the follower

1307
01:03:50,390 --> 01:03:51,440
already has

1308
01:03:51,440 --> 01:03:55,250
what should the follower do and rule six

1309
01:03:55,250 --> 01:03:57,350
and figure thirteen says something but I

1310
01:03:57,350 --> 01:03:59,480
think equally valid response to that is

1311
01:03:59,480 --> 01:04:01,340
that the follower can ignore a snapshot

1312
01:04:01,340 --> 01:04:07,460
that clearly is from the past I don't

1313
01:04:07,460 --> 01:04:12,070
really understand that rule six okay I

1314
01:04:12,070 --> 01:04:17,990
want to move on to sort of somewhat more

1315
01:04:17,990 --> 01:04:21,710
conceptual topic for a bit so far we

1316
01:04:21,710 --> 01:04:24,730
haven't really tried to nail down

1317
01:04:24,730 --> 01:04:27,020
anything about what it meant to be

1318
01:04:27,020 --> 01:04:28,610
correct

1319
01:04:28,610 --> 01:04:33,860
what I meant for a replicated service

1320
01:04:33,860 --> 01:04:36,290
already any other kind of service to be

1321
01:04:36,290 --> 01:04:39,050
behaving correctly and the reason why

1322
01:04:39,050 --> 01:04:42,320
and you know whatever for most of my

1323
01:04:42,320 --> 01:04:44,240
life I managed to get by without

1324
01:04:44,240 --> 01:04:46,070
worrying too much about precise

1325
01:04:46,070 --> 01:04:47,960
definitions of correctness but the fact

1326
01:04:47,960 --> 01:04:49,730
is that you know if you're trying to

1327
01:04:49,730 --> 01:04:51,380
optimize something or you're trying to

1328
01:04:51,380 --> 01:04:53,030
think through some weird corner case

1329
01:04:53,030 --> 01:04:55,820
it's often handy to actually have a more

1330
01:04:55,820 --> 01:04:58,100
or less formal way of deciding is that

1331
01:04:58,100 --> 01:05:00,470
behavior correct or not correct and so

1332
01:05:00,470 --> 01:05:01,910
you know for here what we're talking

1333
01:05:01,910 --> 01:05:03,680
about is you know clients are sending in

1334
01:05:03,680 --> 01:05:05,540
requests to the to our replicated

1335
01:05:05,540 --> 01:05:07,700
service with our PC maybe they'll be

1336
01:05:07,700 --> 01:05:09,710
sending who knows well maybe the service

1337
01:05:09,710 --> 01:05:11,840
is crash it can be starting and you know

1338
01:05:11,840 --> 01:05:14,210
loading snapshots or whatever the client

1339
01:05:14,210 --> 01:05:15,950
sends in a request and gets a response

1340
01:05:15,950 --> 01:05:18,320
like is that response correct how are we

1341
01:05:18,320 --> 01:05:20,090
supposed to how are we supposed to tell

1342
01:05:20,090 --> 01:05:22,430
whether response a would be correct or

1343
01:05:22,430 --> 01:05:26,210
response B so we need a notion we need a

1344
01:05:26,210 --> 01:05:27,740
pretty formal notion of distinguishing

1345
01:05:27,740 --> 01:05:30,050
oh that's okay from now that would be a

1346
01:05:30,050 --> 01:05:33,770
wrong answer and for this lab the our

1347
01:05:33,770 --> 01:05:36,230
notion of correctness is linearize

1348
01:05:36,230 --> 01:05:42,410
ability and I mentioned strong

1349
01:05:42,410 --> 01:05:43,910
consistency and some of the papers I

1350
01:05:43,910 --> 01:05:45,490
mentioned strong consistency and

1351
01:05:45,490 --> 01:05:47,270
basically equivalent to linearize

1352
01:05:47,270 --> 01:05:50,540
ability linearize ability is a sort of a

1353
01:05:50,540 --> 01:05:54,580
formalization of more or less of the

1354
01:05:54,580 --> 01:05:57,410
behavior you would expect if there was

1355
01:05:57,410 --> 01:05:59,720
just one server and it didn't crash and

1356
01:05:59,720 --> 01:06:02,210
it executed the command client requests

1357
01:06:02,210 --> 01:06:04,910
one at a time and you know nothing funny

1358
01:06:04,910 --> 01:06:09,170
ever happened so it has it has a

1359
01:06:09,170 --> 01:06:12,350
definition and the definition I'll write

1360
01:06:12,350 --> 01:06:14,110
out the definition then talk about it so

1361
01:06:14,110 --> 01:06:24,610
so an execution history is linearizable

1362
01:06:24,610 --> 01:06:30,830
linearizable and this is in the notes if

1363
01:06:30,830 --> 01:06:33,140
there exists a total order so an

1364
01:06:33,140 --> 01:06:34,910
execution history is a sequence of

1365
01:06:34,910 --> 01:06:37,220
client requests maybe many requests from

1366
01:06:37,220 --> 01:06:39,510
many clients

1367
01:06:39,510 --> 01:06:46,890
if there's some total order of the

1368
01:06:46,890 --> 01:06:53,640
operations in the history it matches the

1369
01:06:53,640 --> 01:06:55,560
real-time order of requests so if one

1370
01:06:55,560 --> 01:06:56,250
request

1371
01:06:56,250 --> 01:06:57,990
if client sends out a request and gets a

1372
01:06:57,990 --> 01:07:01,200
response and then later in time another

1373
01:07:01,200 --> 01:07:02,730
client sends out a request and I get a

1374
01:07:02,730 --> 01:07:04,890
response those two requests are ordered

1375
01:07:04,890 --> 01:07:07,770
because one of them's started after the

1376
01:07:07,770 --> 01:07:08,940
other one finished

1377
01:07:08,940 --> 01:07:12,300
so it's linearizable history is

1378
01:07:12,300 --> 01:07:13,860
linearizable if there exists an order of

1379
01:07:13,860 --> 01:07:15,900
the operations in the history that

1380
01:07:15,900 --> 01:07:23,250
matches real-time for non concurrent

1381
01:07:23,250 --> 01:07:25,860
requests that is for a request to didn't

1382
01:07:25,860 --> 01:07:42,270
overlap in time and each read you can

1383
01:07:42,270 --> 01:07:44,490
think of it as each read sees the value

1384
01:07:44,490 --> 01:07:46,740
from the most immediately preceding

1385
01:07:46,740 --> 01:07:56,760
right to the the same piece of data most

1386
01:07:56,760 --> 01:08:08,400
recent right in the order all right this

1387
01:08:08,400 --> 01:08:10,830
is the definition let me illustrate what

1388
01:08:10,830 --> 01:08:12,620
it means by running through an example

1389
01:08:12,620 --> 01:08:15,210
so first of all the history is a record

1390
01:08:15,210 --> 01:08:16,620
of client operations so this is a

1391
01:08:16,620 --> 01:08:18,510
definition that you can apply from

1392
01:08:18,510 --> 01:08:20,580
outside this definition doesn't appeal

1393
01:08:20,580 --> 01:08:23,430
in any way to what happens inside the

1394
01:08:23,430 --> 01:08:24,540
implementation or how the implementation

1395
01:08:24,540 --> 01:08:27,180
works it's something that we can if we

1396
01:08:27,180 --> 01:08:30,000
see a system operating and we can watch

1397
01:08:30,000 --> 01:08:32,460
the messages that come in and out we can

1398
01:08:32,460 --> 01:08:34,290
answer the question was that execution

1399
01:08:34,290 --> 01:08:42,410
that we observe linearizable so let me

1400
01:08:44,830 --> 01:08:47,600
let me write out of history and talk

1401
01:08:47,600 --> 01:08:51,160
about why it is or isn't linearizable

1402
01:08:53,529 --> 01:09:01,700
all right so here's an example the new

1403
01:09:01,700 --> 01:09:03,380
eyes ability talks about operations that

1404
01:09:03,380 --> 01:09:05,540
start at one point and end at another

1405
01:09:05,540 --> 01:09:07,250
and so this corresponds to the time at

1406
01:09:07,250 --> 01:09:10,279
which a client sends a request and then

1407
01:09:10,279 --> 01:09:13,970
later receives a reply so let us suppose

1408
01:09:13,970 --> 01:09:16,100
that our history says that at at some

1409
01:09:16,100 --> 01:09:19,189
particular time this time some client

1410
01:09:19,189 --> 01:09:22,160
sent a write request for the data item

1411
01:09:22,160 --> 01:09:24,580
named X and asked for it to be set to 1

1412
01:09:24,580 --> 01:09:28,670
and then time passed and at the second

1413
01:09:28,670 --> 01:09:30,170
vertical bar is when that client got a

1414
01:09:30,170 --> 01:09:31,910
reply through send a request at this

1415
01:09:31,910 --> 01:09:33,290
point you know time pass who knows

1416
01:09:33,290 --> 01:09:34,700
what's happening when the client got a

1417
01:09:34,700 --> 01:09:37,729
reply there and then later in time that

1418
01:09:37,729 --> 01:09:39,020
client or some other client doesn't

1419
01:09:39,020 --> 01:09:40,279
really matter

1420
01:09:40,279 --> 01:09:43,100
sends a write request again for item X

1421
01:09:43,100 --> 01:09:45,470
and value 2 and gets a response to that

1422
01:09:45,470 --> 01:09:52,370
right meanwhile some client sends a read

1423
01:09:52,370 --> 01:09:56,990
for X and gets value 2 and sent the

1424
01:09:56,990 --> 01:09:58,820
request there and got the response with

1425
01:09:58,820 --> 01:10:00,890
value 2 there and there's another

1426
01:10:00,890 --> 01:10:03,320
request that we observed it's a part of

1427
01:10:03,320 --> 01:10:07,280
the history request was sent to read

1428
01:10:07,280 --> 01:10:12,830
value X and it got value 1 back and so

1429
01:10:12,830 --> 01:10:14,750
when we have a history like this you

1430
01:10:14,750 --> 01:10:16,160
know the question were that you asked

1431
01:10:16,160 --> 01:10:17,690
about this history is is this a

1432
01:10:17,690 --> 01:10:20,180
linearizable history that is did the

1433
01:10:20,180 --> 01:10:22,310
machinery did the service did the system

1434
01:10:22,310 --> 01:10:23,930
that produced this history and was that

1435
01:10:23,930 --> 01:10:28,430
a linearizable system or did it produce

1436
01:10:28,430 --> 01:10:30,380
a linearizable history in this case if

1437
01:10:30,380 --> 01:10:31,790
this history is not linear inaudible

1438
01:10:31,790 --> 01:10:36,560
then then Lisa we're talking about I

1439
01:10:36,560 --> 01:10:38,750
have 3 we know we have a problem there

1440
01:10:38,750 --> 01:10:42,260
must be some some bug ok so we need to

1441
01:10:42,260 --> 01:10:43,460
analyze this to figure out if it's

1442
01:10:43,460 --> 01:10:45,980
linearizable there's linear linearize

1443
01:10:45,980 --> 01:10:48,830
ability requires us to produce an order

1444
01:10:48,830 --> 01:10:52,400
you know one by one order of the four

1445
01:10:52,400 --> 01:10:54,800
operations in that history so we know

1446
01:10:54,800 --> 01:10:55,850
we're looking for an order and there's

1447
01:10:55,850 --> 01:10:57,050
two constraints on the

1448
01:10:57,050 --> 01:11:03,890
order one is if one operation finished

1449
01:11:03,890 --> 01:11:07,640
before another started then the one that

1450
01:11:07,640 --> 01:11:08,900
finished first has to come first in the

1451
01:11:08,900 --> 01:11:13,790
history the other is if some read sees a

1452
01:11:13,790 --> 01:11:17,930
particular written value then the read

1453
01:11:17,930 --> 01:11:20,920
must come after the write in the order

1454
01:11:20,920 --> 01:11:23,090
all right so we want to order so we're

1455
01:11:23,090 --> 01:11:24,380
gonna produce an order that has four

1456
01:11:24,380 --> 01:11:26,650
entries the two rights and the two leads

1457
01:11:26,650 --> 01:11:29,030
I'm gonna draw with arrows that

1458
01:11:29,030 --> 01:11:31,340
constraints implied by those two rules

1459
01:11:31,340 --> 01:11:33,800
and then our order is gonna have to obey

1460
01:11:33,800 --> 01:11:36,440
these constraints so one constraint is

1461
01:11:36,440 --> 01:11:39,200
that this write finished before this

1462
01:11:39,200 --> 01:11:41,270
write started and therefore one of the

1463
01:11:41,270 --> 01:11:44,420
ordering constraints is that this write

1464
01:11:44,420 --> 01:11:47,480
must appear in the total order before

1465
01:11:47,480 --> 01:11:51,290
this write this read saw the value of

1466
01:11:51,290 --> 01:11:56,870
two so in the total order the most

1467
01:11:56,870 --> 01:11:59,090
recent right that this read must come

1468
01:11:59,090 --> 01:12:00,740
after this right and this write must be

1469
01:12:00,740 --> 01:12:03,610
the most recent right so that means that

1470
01:12:03,610 --> 01:12:06,320
in the total order we must see the right

1471
01:12:06,320 --> 01:12:08,930
of X - 2 and then after it the read of X

1472
01:12:08,930 --> 01:12:19,670
it yields - and this this read of X of 1

1473
01:12:19,670 --> 01:12:21,050
if we assume that the X didn't already

1474
01:12:21,050 --> 01:12:23,210
have the value 1 there there must be in

1475
01:12:23,210 --> 01:12:27,020
this relationship and that is the read

1476
01:12:27,020 --> 01:12:29,240
must come after the right and this read

1477
01:12:29,240 --> 01:12:32,750
also must become for this right and

1478
01:12:32,750 --> 01:12:35,480
maybe there's some other restrictions -

1479
01:12:35,480 --> 01:12:37,910
anyway we can take these we can take

1480
01:12:37,910 --> 01:12:39,260
this set of arrows and flatten it out

1481
01:12:39,260 --> 01:12:41,090
into an order and that actually works so

1482
01:12:41,090 --> 01:12:44,030
the order that's the total order that

1483
01:12:44,030 --> 01:12:45,590
demonstrates that this history is

1484
01:12:45,590 --> 01:12:50,020
linearizable is first the right of x - 1

1485
01:12:50,020 --> 01:12:56,510
then the read of x yielding 1 then the

1486
01:12:56,510 --> 01:13:00,650
right of x - 2 and the read of x that

1487
01:13:00,650 --> 01:13:03,190
yields 2

1488
01:13:03,920 --> 01:13:06,390
alright so the fact that there is this

1489
01:13:06,390 --> 01:13:07,920
order that does obey the ordering

1490
01:13:07,920 --> 01:13:09,449
constraints shows that this history is

1491
01:13:09,449 --> 01:13:13,980
linearize ability and doesn't you know

1492
01:13:13,980 --> 01:13:15,300
if we're worried about the system that

1493
01:13:15,300 --> 01:13:17,940
produced this history whether it's a but

1494
01:13:17,940 --> 01:13:20,610
that system is linearizable then this

1495
01:13:20,610 --> 01:13:22,110
particular example we saw it doesn't

1496
01:13:22,110 --> 01:13:24,660
contradict the presumption that the

1497
01:13:24,660 --> 01:13:29,040
system is linearizable any questions

1498
01:13:29,040 --> 01:13:45,360
about what I just did each read sees you

1499
01:13:45,360 --> 01:13:48,150
know read of X the value it sees must be

1500
01:13:48,150 --> 01:13:51,600
them value written by the most the most

1501
01:13:51,600 --> 01:13:56,330
recent proceeding right in the order so

1502
01:13:56,330 --> 01:13:58,920
you know in this case in this case we're

1503
01:13:58,920 --> 01:14:00,239
totally ok with this order because this

1504
01:14:00,239 --> 01:14:03,449
read the value it saw is indeed the

1505
01:14:03,449 --> 01:14:04,770
value written by the most recent write

1506
01:14:04,770 --> 01:14:08,250
in this order and this read the value it

1507
01:14:08,250 --> 01:14:12,630
sighs I mean in informally it's that

1508
01:14:12,630 --> 01:14:15,420
reads can't real should not be yielding

1509
01:14:15,420 --> 01:14:17,940
stale data if I write something in Rita

1510
01:14:17,940 --> 01:14:20,040
back gosh I should see the value I wrote

1511
01:14:20,040 --> 01:14:21,870
and that's like a formalization of the

1512
01:14:21,870 --> 01:14:24,230
notion that

1513
01:14:27,530 --> 01:14:34,130
oh yes oh yeah yeah all right let me let

1514
01:14:34,130 --> 01:14:40,430
me he's right up example that's not

1515
01:14:40,430 --> 01:14:44,810
indeed linearizable so example two let's

1516
01:14:44,810 --> 01:14:48,110
suppose our history is we had a right of

1517
01:14:48,110 --> 01:14:57,880
X value one right back with value two

1518
01:15:14,090 --> 01:15:16,640
and so this one we also want to write

1519
01:15:16,640 --> 01:15:20,120
out the arrows and so we know what the

1520
01:15:20,120 --> 01:15:21,920
constraints are on any total order we

1521
01:15:21,920 --> 01:15:26,120
might find the right of X to one because

1522
01:15:26,120 --> 01:15:28,580
of time because it finished in real time

1523
01:15:28,580 --> 01:15:31,130
before the right x to started and must

1524
01:15:31,130 --> 01:15:36,200
come before in any satisfying order we

1525
01:15:36,200 --> 01:15:38,510
produce the right of Ecsta two has to

1526
01:15:38,510 --> 01:15:41,060
come before the right before the read of

1527
01:15:41,060 --> 01:15:45,280
X that yields two so we have this arrow

1528
01:15:46,840 --> 01:15:49,400
the read of X had to finished before the

1529
01:15:49,400 --> 01:15:51,410
read of X to one started so we have this

1530
01:15:51,410 --> 01:16:00,260
arrow and the read of X to one because

1531
01:16:00,260 --> 01:16:03,830
it saw value one has to come after the

1532
01:16:03,830 --> 01:16:06,140
right of X - 1 and more crucially before

1533
01:16:06,140 --> 01:16:09,770
the right of X 2 - right so we can't

1534
01:16:09,770 --> 01:16:12,230
have this read of X yielding one if it's

1535
01:16:12,230 --> 01:16:14,240
immediately preceded by I'll write out X

1536
01:16:14,240 --> 01:16:18,250
- 2 so we also have this arrow like this

1537
01:16:18,250 --> 01:16:23,060
and because there's a cycle in these

1538
01:16:23,060 --> 01:16:27,110
constraints there's no order that can

1539
01:16:27,110 --> 01:16:29,150
obey all these constraints and therefore

1540
01:16:29,150 --> 01:16:35,180
this history is not linearizable and so

1541
01:16:35,180 --> 01:16:37,660
the system that produced it is

1542
01:16:37,660 --> 01:16:42,880
is not a linearizable system you know

1543
01:16:42,880 --> 01:16:44,320
would be linearizable the history was

1544
01:16:44,320 --> 01:16:47,740
missing any one of these three and I

1545
01:16:47,740 --> 01:17:05,770
would break the cycle yes maybe I'm not

1546
01:17:05,770 --> 01:17:08,620
sure because suppose or I don't know how

1547
01:17:08,620 --> 01:17:11,230
to incorporate very strange things like

1548
01:17:11,230 --> 01:17:16,870
supposing somebody red 27 you know it

1549
01:17:16,870 --> 01:17:18,910
doesn't really if there's no right of 27

1550
01:17:18,910 --> 01:17:22,360
a read of 27 doesn't at least the way

1551
01:17:22,360 --> 01:17:23,710
I've written out the rules doesn't sort

1552
01:17:23,710 --> 01:17:26,620
of well there may be some sort of anti

1553
01:17:26,620 --> 01:17:29,200
dependency that you would construct okay

1554
01:17:29,200 --> 01:17:33,130
um I will continue this discussion next

1555
01:17:33,130 --> 00:00:00,000
week

